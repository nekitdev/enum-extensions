{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"enum-extensions Enhanced enumerations for Python. Installing Python 3.7 or above is required. pip Installing the library with pip is quite simple: $ pip install enum-extensions Alternatively, the library can be installed from source: $ git clone https://github.com/nekitdev/enum-extensions.git $ cd enum-extensions $ python -m pip install . poetry You can add enum-extensions as a dependency with the following command: $ poetry add enum-extensions Or by directly specifying it in the configuration like so: [tool.poetry.dependencies] enum-extensions = \"^0.1.0\" Alternatively, you can add it directly from the source: [tool.poetry.dependencies.enum-extensions] git = \"https://github.com/nekitdev/enum-extensions.git\" Examples Creating a simple enumeration: from enum_extensions import Enum class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Accessing members by name or by value: red = Color . RED # <Color.RED: 1> green = Color [ \"GREEN\" ] # <Color.GREEN: 2> blue = Color ( 3 ) # <Color.BLUE> Documentation You can find the documentation here . Support If you need support with the library, you can send an email or refer to the official Discord server . Changelog You can find the changelog here . Security Policy You can find the Security Policy of enum-extensions here . Contributing If you are interested in contributing to enum-extensions , make sure to take a look at the Contributing Guide , as well as the Code of Conduct . License enum-extensions is licensed under the MIT License terms. See License for details.","title":"Index"},{"location":"#enum-extensions","text":"Enhanced enumerations for Python.","title":"enum-extensions"},{"location":"#installing","text":"Python 3.7 or above is required.","title":"Installing"},{"location":"#pip","text":"Installing the library with pip is quite simple: $ pip install enum-extensions Alternatively, the library can be installed from source: $ git clone https://github.com/nekitdev/enum-extensions.git $ cd enum-extensions $ python -m pip install .","title":"pip"},{"location":"#poetry","text":"You can add enum-extensions as a dependency with the following command: $ poetry add enum-extensions Or by directly specifying it in the configuration like so: [tool.poetry.dependencies] enum-extensions = \"^0.1.0\" Alternatively, you can add it directly from the source: [tool.poetry.dependencies.enum-extensions] git = \"https://github.com/nekitdev/enum-extensions.git\"","title":"poetry"},{"location":"#examples","text":"Creating a simple enumeration: from enum_extensions import Enum class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Accessing members by name or by value: red = Color . RED # <Color.RED: 1> green = Color [ \"GREEN\" ] # <Color.GREEN: 2> blue = Color ( 3 ) # <Color.BLUE>","title":"Examples"},{"location":"#documentation","text":"You can find the documentation here .","title":"Documentation"},{"location":"#support","text":"If you need support with the library, you can send an email or refer to the official Discord server .","title":"Support"},{"location":"#changelog","text":"You can find the changelog here .","title":"Changelog"},{"location":"#security-policy","text":"You can find the Security Policy of enum-extensions here .","title":"Security Policy"},{"location":"#contributing","text":"If you are interested in contributing to enum-extensions , make sure to take a look at the Contributing Guide , as well as the Code of Conduct .","title":"Contributing"},{"location":"#license","text":"enum-extensions is licensed under the MIT License terms. See License for details.","title":"License"},{"location":"changelog/","text":"Changelog 0.1.0 (2022-07-15) Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#010-2022-07-15","text":"Initial release.","title":"0.1.0 (2022-07-15)"},{"location":"enums/","text":"Enums Prerequisites Code snippets and examples below are using several common imports and types, which are mainly omitted for simplicity: from typing import TypeVar # for various typing purposes from enum_extensions import ( # library imports used in examples # enumerations Enum , IntEnum , StringEnum , # auto items auto , # (non-)members member , non_member , ) T = TypeVar ( \"T\" ) # general (and generic) type variable E = TypeVar ( \"E\" , bound = Enum ) # enum type variable Creating Enumerations There are many ways to create enumerations. This can be done in a classical way: class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Similar to the standard enum module, enum-extensions has an Auto type and an auto function: class Color ( Enum ): RED = auto () GREEN = auto () BLUE = auto () Enumerations can be created without explicit class usage: Color = Enum ( \"Color\" , ( \"RED\" , \"GREEN\" , \"BLUE\" )) Strings can also be used here: Color = Enum ( \"Color\" , \"RED GREEN BLUE\" ) Mappings work just as nicely: Color = Enum ( \"Color\" , { \"RED\" : 1 , \"GREEN\" : 2 , \"BLUE\" : 3 }) You can also use keyword arguments in order to define members: Color = Enum ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 3 ) Same with auto , of course: Color = Enum ( \"Color\" , RED = auto (), GREEN = auto (), BLUE = auto ()) All code snippets above produce Color enumeration in the end, which has the following members: <Color.RED: 1> <Color.GREEN: 2> <Color.BLUE: 3> See Enum.create documentation for more details on creation API. Member Attributes Enumeration members have several useful attributes: name , which represents their actual name; value , which contains their value; title_name , which is a more human-readable version of their name . Member Access Consider the following enumeration: class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Enumeration members can be accessed by their name via attributes: red = Color . RED # <Color.RED: 1> Or via subscription: green = Color [ \"GREEN\" ] # <Color.GREEN: 2> Alternatively, by-value access can be used: blue = Color ( 3 ) # <Color.BLUE: 3> Advanced Access Enumeration members can be accessed with case insensitive strings (via Enum.from_name ): class Test ( Enum ): TEST = 13 test = Test . from_name ( \"test\" ) # <Test.TEST: 13> Note that if two members have same case insensitive name version, last in wins! Also keep in mind Enum.from_name will not work with composite flags! Non-existent names raise a KeyError : >>> Test . from_name ( \"unknown\" ) Traceback ( most recent call last ): ... KeyError : \"unknown\" There is also Enum.from_value , which can be used to lookup members by value, optionally defaulting to some value: class Test ( Enum ): TEST = 25 test = Test . from_value ( 25 ) # <Test.TEST: 25> default = Test . from_value ( 42 , 25 ) # <Test.TEST: 25> Non-present values without defaults will to raise a ValueError : >>> Test . from_value ( 42 ) Traceback ( most recent call last ): ... ValueError : 42 is not a valid ` Test ` Enum.from_data is used to find members either by name or by value with an optional default. Enum.from_name is called if given a string, and otherwise (including on failure), Enum.from_value is applied with default : class Test ( Enum ): TEST = 42 test = Test . from_data ( \"test\" ) # <Test.TEST: 42> test = Test . from_data ( 42 ) # <Test.TEST: 42> test = Test . from_data ( 25 , 42 ) # <Test.TEST: 42> Unknown names or values raise a ValueError : >>> Test . from_data ( 13 ) Traceback ( most recent call last ): ... ValueError : 13 is not a valid ` Test ` >>> Test . from_data ( \"unknown\" ) Traceback ( most recent call last ): ... ValueError : \"unknown\" is not a valid ` Test ` Iteration It is possible to iterate over unique enumeration members: >>> Color = Enum ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 3 ) >>> for color in Color : ... print ( Color . title ) Red Green Blue Or over all members, including aliases: >>> Color = Enum ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 3 , R = 1 , G = 2 , B = 3 ) >>> for name , color in Color . members . items (): ... print ( name , color . name ) RED RED GREEN GREEN BLUE BLUE R RED G GREEN B BLUE Length Enumerations are aware of their unique member count, which can be accessed using len : >>> Color = Enum ( \"Color\" , ( \"RED\" , \"GREEN\" , \"BLUE\" )) >>> len ( Color ) 3 Container Checks Enumerations can check if the member belongs to them: >>> Color = Enum ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 3 ) >>> Shade = Enum ( \"Shade\" , BLACK = 0 , WHITE = 100 ) >>> Color . BLUE in Color True >>> Shade . WHITE in Shade True >>> Color . GREEN in Shade False >>> Shade . BLACK in Color False This also works nicely with values: >>> 1 in Color True >>> 100 in Color False Initialization Arguments Enumeration members that have tuple values but do not subclass tuple are interpreted as values passed to the __init__ of their class: from math import sqrt class Point : ORIGIN = ( 0 , 0 ) def __init__ ( self , x : int , y : int ) -> None : self . x = x self . y = y @property def distance_from_origin ( self ) -> float : return sqrt ( self . x * self . x + self . y * self . y ) origin = Point . ORIGIN # <Point.ORIGIN: (0, 0)> print ( origin . value ) # (0, 0) print ( origin . distance_from_origin ) # 0.0 Mutability Taking the (extremely familiar) enumeration: class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Members can not be deleted: >>> del Color . RED Traceback ( most recent call last ): ... AttributeError : can not delete enum member : ` RED ` They can not be reassigned, either: >>> Color . BLUE = 0 Traceback ( most recent call last ): ... AttributeError : can not reassign enum member : ` BLUE ` However, new members can be added to an enumeration via Enum.add_member or Enum.update methods: >>> Color . add_member ( \"BLACK\" , 0 ) < Color . BLACK : 0 > >>> Color . update ( WHITE = 4 ) >>> ( Color . BLACK , Color . WHITE ) ( < Color . BLACK : 0 > , < Color . WHITE : 4 > ) String Enumeration StringEnum is a simple type derived from Enum and str , which only affects enum_generate_next_value by making it use the case-folded version of the member name: class Status ( StringEnum ): OK = auto () ok = Status . OK # <Status.OK: ok> Any operations derived from str will force members to lose their membership: title = Status . OK . title () # Ok Integer Enumeration IntEnum is an enumeration derived from Enum and int , which allows its members to act as integers: class Color ( IntEnum ): RED = 1 GREEN = 2 BLUE = 3 red = Color . RED # <Color.RED: 1> value = red + 2 # 3 Note how members also lose their membership when int operations are applied. Enforcing (Non-)Members One can combine Member and NonMember types to force members to be included or excluded via member and non_member functions, respectively. Using member to enforce membership: def identity ( item : T ) -> T : return item class Function ( Enum ): IDENTITY = member ( identity ) function = Function . IDENTITY # <Function.IDENTITY: <function identity at ...>> Removing the call above changes the behavior: function = Function . IDENTITY # <function identity at ...> Applying non_member to protect items from becoming members: class Test ( Enum ): TEST = non_member ( 42 ) test = Test . TEST # 42 Removing the call above alters the behavior: class Test ( Enum ): TEST = 42 test = Test . TEST # <Test.TEST: 42>","title":"Enums"},{"location":"enums/#enums","text":"","title":"Enums"},{"location":"enums/#prerequisites","text":"Code snippets and examples below are using several common imports and types, which are mainly omitted for simplicity: from typing import TypeVar # for various typing purposes from enum_extensions import ( # library imports used in examples # enumerations Enum , IntEnum , StringEnum , # auto items auto , # (non-)members member , non_member , ) T = TypeVar ( \"T\" ) # general (and generic) type variable E = TypeVar ( \"E\" , bound = Enum ) # enum type variable","title":"Prerequisites"},{"location":"enums/#creating-enumerations","text":"There are many ways to create enumerations. This can be done in a classical way: class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Similar to the standard enum module, enum-extensions has an Auto type and an auto function: class Color ( Enum ): RED = auto () GREEN = auto () BLUE = auto () Enumerations can be created without explicit class usage: Color = Enum ( \"Color\" , ( \"RED\" , \"GREEN\" , \"BLUE\" )) Strings can also be used here: Color = Enum ( \"Color\" , \"RED GREEN BLUE\" ) Mappings work just as nicely: Color = Enum ( \"Color\" , { \"RED\" : 1 , \"GREEN\" : 2 , \"BLUE\" : 3 }) You can also use keyword arguments in order to define members: Color = Enum ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 3 ) Same with auto , of course: Color = Enum ( \"Color\" , RED = auto (), GREEN = auto (), BLUE = auto ()) All code snippets above produce Color enumeration in the end, which has the following members: <Color.RED: 1> <Color.GREEN: 2> <Color.BLUE: 3> See Enum.create documentation for more details on creation API.","title":"Creating Enumerations"},{"location":"enums/#member-attributes","text":"Enumeration members have several useful attributes: name , which represents their actual name; value , which contains their value; title_name , which is a more human-readable version of their name .","title":"Member Attributes"},{"location":"enums/#member-access","text":"Consider the following enumeration: class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Enumeration members can be accessed by their name via attributes: red = Color . RED # <Color.RED: 1> Or via subscription: green = Color [ \"GREEN\" ] # <Color.GREEN: 2> Alternatively, by-value access can be used: blue = Color ( 3 ) # <Color.BLUE: 3>","title":"Member Access"},{"location":"enums/#advanced-access","text":"Enumeration members can be accessed with case insensitive strings (via Enum.from_name ): class Test ( Enum ): TEST = 13 test = Test . from_name ( \"test\" ) # <Test.TEST: 13> Note that if two members have same case insensitive name version, last in wins! Also keep in mind Enum.from_name will not work with composite flags! Non-existent names raise a KeyError : >>> Test . from_name ( \"unknown\" ) Traceback ( most recent call last ): ... KeyError : \"unknown\" There is also Enum.from_value , which can be used to lookup members by value, optionally defaulting to some value: class Test ( Enum ): TEST = 25 test = Test . from_value ( 25 ) # <Test.TEST: 25> default = Test . from_value ( 42 , 25 ) # <Test.TEST: 25> Non-present values without defaults will to raise a ValueError : >>> Test . from_value ( 42 ) Traceback ( most recent call last ): ... ValueError : 42 is not a valid ` Test ` Enum.from_data is used to find members either by name or by value with an optional default. Enum.from_name is called if given a string, and otherwise (including on failure), Enum.from_value is applied with default : class Test ( Enum ): TEST = 42 test = Test . from_data ( \"test\" ) # <Test.TEST: 42> test = Test . from_data ( 42 ) # <Test.TEST: 42> test = Test . from_data ( 25 , 42 ) # <Test.TEST: 42> Unknown names or values raise a ValueError : >>> Test . from_data ( 13 ) Traceback ( most recent call last ): ... ValueError : 13 is not a valid ` Test ` >>> Test . from_data ( \"unknown\" ) Traceback ( most recent call last ): ... ValueError : \"unknown\" is not a valid ` Test `","title":"Advanced Access"},{"location":"enums/#iteration","text":"It is possible to iterate over unique enumeration members: >>> Color = Enum ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 3 ) >>> for color in Color : ... print ( Color . title ) Red Green Blue Or over all members, including aliases: >>> Color = Enum ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 3 , R = 1 , G = 2 , B = 3 ) >>> for name , color in Color . members . items (): ... print ( name , color . name ) RED RED GREEN GREEN BLUE BLUE R RED G GREEN B BLUE","title":"Iteration"},{"location":"enums/#length","text":"Enumerations are aware of their unique member count, which can be accessed using len : >>> Color = Enum ( \"Color\" , ( \"RED\" , \"GREEN\" , \"BLUE\" )) >>> len ( Color ) 3","title":"Length"},{"location":"enums/#container-checks","text":"Enumerations can check if the member belongs to them: >>> Color = Enum ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 3 ) >>> Shade = Enum ( \"Shade\" , BLACK = 0 , WHITE = 100 ) >>> Color . BLUE in Color True >>> Shade . WHITE in Shade True >>> Color . GREEN in Shade False >>> Shade . BLACK in Color False This also works nicely with values: >>> 1 in Color True >>> 100 in Color False","title":"Container Checks"},{"location":"enums/#initialization-arguments","text":"Enumeration members that have tuple values but do not subclass tuple are interpreted as values passed to the __init__ of their class: from math import sqrt class Point : ORIGIN = ( 0 , 0 ) def __init__ ( self , x : int , y : int ) -> None : self . x = x self . y = y @property def distance_from_origin ( self ) -> float : return sqrt ( self . x * self . x + self . y * self . y ) origin = Point . ORIGIN # <Point.ORIGIN: (0, 0)> print ( origin . value ) # (0, 0) print ( origin . distance_from_origin ) # 0.0","title":"Initialization Arguments"},{"location":"enums/#mutability","text":"Taking the (extremely familiar) enumeration: class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Members can not be deleted: >>> del Color . RED Traceback ( most recent call last ): ... AttributeError : can not delete enum member : ` RED ` They can not be reassigned, either: >>> Color . BLUE = 0 Traceback ( most recent call last ): ... AttributeError : can not reassign enum member : ` BLUE ` However, new members can be added to an enumeration via Enum.add_member or Enum.update methods: >>> Color . add_member ( \"BLACK\" , 0 ) < Color . BLACK : 0 > >>> Color . update ( WHITE = 4 ) >>> ( Color . BLACK , Color . WHITE ) ( < Color . BLACK : 0 > , < Color . WHITE : 4 > )","title":"Mutability"},{"location":"enums/#string-enumeration","text":"StringEnum is a simple type derived from Enum and str , which only affects enum_generate_next_value by making it use the case-folded version of the member name: class Status ( StringEnum ): OK = auto () ok = Status . OK # <Status.OK: ok> Any operations derived from str will force members to lose their membership: title = Status . OK . title () # Ok","title":"String Enumeration"},{"location":"enums/#integer-enumeration","text":"IntEnum is an enumeration derived from Enum and int , which allows its members to act as integers: class Color ( IntEnum ): RED = 1 GREEN = 2 BLUE = 3 red = Color . RED # <Color.RED: 1> value = red + 2 # 3 Note how members also lose their membership when int operations are applied.","title":"Integer Enumeration"},{"location":"enums/#enforcing-non-members","text":"One can combine Member and NonMember types to force members to be included or excluded via member and non_member functions, respectively. Using member to enforce membership: def identity ( item : T ) -> T : return item class Function ( Enum ): IDENTITY = member ( identity ) function = Function . IDENTITY # <Function.IDENTITY: <function identity at ...>> Removing the call above changes the behavior: function = Function . IDENTITY # <function identity at ...> Applying non_member to protect items from becoming members: class Test ( Enum ): TEST = non_member ( 42 ) test = Test . TEST # 42 Removing the call above alters the behavior: class Test ( Enum ): TEST = 42 test = Test . TEST # <Test.TEST: 42>","title":"Enforcing (Non-)Members"},{"location":"flags/","text":"Flags Prerequisites Code snippets and examples below are using several common imports and types, which are mainly omitted for simplicity: from typing import TypeVar # for various typing purposes from enum_extensions import ( # library imports used in examples # flag boundary FlagBoundary , # boundaries CONFORM , KEEP , STRICT , # flags Flag , IntFlag , # auto items auto , ) F = TypeVar ( \"F\" , bound = Flag ) # flag type variable FlagBoundary FlagBoundary is an enumeration with the values STRICT , CONFORM and KEEP which allows for more fine-grained control over how invalid (or, rather, out-of-range ) values are dealt with in Flag types. STRICT Out-of-range values cause ValueError . This is the default for Flag . class StrictFlag ( Flag , boundary = STRICT ): RED = auto () GREEN = auto () BLUE = auto () >>> StrictFlag (( 1 << 2 ) + ( 1 << 4 )) Traceback ( most recent call last ): ... ValueError : invalid value 0x14 in ` StrictFlag ` : given 0b0 10100 allowed 0b0 00111 CONFORM Out-of-range values have invalid values removed, leaving a valid Flag member. class ConformFlag ( Flag , boundary = CONFORM ): RED = auto () GREEN = auto () BLUE = auto () >>> ConformFlag (( 1 << 2 ) + ( 1 << 4 )) < ConformFlag . BLUE : 4 > KEEP Out-of-range values are kept along with the Flag membership. This is the default for IntFlag . class KeepFlag ( Flag , boundary = KEEP ): RED = auto () GREEN = auto () BLUE = auto () >>> KeepFlag (( 1 << 2 ) + ( 1 << 4 )) < KeepFlag . BLUE | 0x10 : 4 > Flag Flag is a special Enum focused around supporting bit-flags along with operations on them, such as & ( AND ), | ( OR ), ^ ( XOR ) and ~ ( INVERT ). from enum_extensions import Flag class P ( Flag ): N = 0 X = 1 W = 2 R = 4 RW = P . R | P . W # <P.W|R: 6> RWX = ~ P . N # <P.X|W|R: 7> RX = RWX ^ P . W # <P.X|R: 5> N = RWX & P . N # <P.N: 0> Iteration Length Flag members know the number of bits in them: >>> len ( RWX ) 3 Non-Zero Checks Calling bool on the Flag member can be used to check if the member is non-zero: >>> bool ( RW ) True >>> bool ( N ) False Container Checks Flags can check if the member belongs to another member: >>> P . R in RW True >>> P . N in RWX False IntFlag IntFlag is a flag derived from Flag and int , which allows its members to act as integers: class Color ( IntFlag ): RED = 1 GREEN = 2 BLUE = 4 red = Color . RED # <Color.RED: 1> value = red + 2 # 3 Note how members also lose their membership when int operations are applied. IntFlag members can be combined with integer values (compared to Flag which only supports checking members): red = Color . RED # <Color.RED: 1> red_blue = red | 4 # <Color.RED|BLUE: 4>","title":"Flags"},{"location":"flags/#flags","text":"","title":"Flags"},{"location":"flags/#prerequisites","text":"Code snippets and examples below are using several common imports and types, which are mainly omitted for simplicity: from typing import TypeVar # for various typing purposes from enum_extensions import ( # library imports used in examples # flag boundary FlagBoundary , # boundaries CONFORM , KEEP , STRICT , # flags Flag , IntFlag , # auto items auto , ) F = TypeVar ( \"F\" , bound = Flag ) # flag type variable","title":"Prerequisites"},{"location":"flags/#flagboundary","text":"FlagBoundary is an enumeration with the values STRICT , CONFORM and KEEP which allows for more fine-grained control over how invalid (or, rather, out-of-range ) values are dealt with in Flag types.","title":"FlagBoundary"},{"location":"flags/#strict","text":"Out-of-range values cause ValueError . This is the default for Flag . class StrictFlag ( Flag , boundary = STRICT ): RED = auto () GREEN = auto () BLUE = auto () >>> StrictFlag (( 1 << 2 ) + ( 1 << 4 )) Traceback ( most recent call last ): ... ValueError : invalid value 0x14 in ` StrictFlag ` : given 0b0 10100 allowed 0b0 00111","title":"STRICT"},{"location":"flags/#conform","text":"Out-of-range values have invalid values removed, leaving a valid Flag member. class ConformFlag ( Flag , boundary = CONFORM ): RED = auto () GREEN = auto () BLUE = auto () >>> ConformFlag (( 1 << 2 ) + ( 1 << 4 )) < ConformFlag . BLUE : 4 >","title":"CONFORM"},{"location":"flags/#keep","text":"Out-of-range values are kept along with the Flag membership. This is the default for IntFlag . class KeepFlag ( Flag , boundary = KEEP ): RED = auto () GREEN = auto () BLUE = auto () >>> KeepFlag (( 1 << 2 ) + ( 1 << 4 )) < KeepFlag . BLUE | 0x10 : 4 >","title":"KEEP"},{"location":"flags/#flag","text":"Flag is a special Enum focused around supporting bit-flags along with operations on them, such as & ( AND ), | ( OR ), ^ ( XOR ) and ~ ( INVERT ). from enum_extensions import Flag class P ( Flag ): N = 0 X = 1 W = 2 R = 4 RW = P . R | P . W # <P.W|R: 6> RWX = ~ P . N # <P.X|W|R: 7> RX = RWX ^ P . W # <P.X|R: 5> N = RWX & P . N # <P.N: 0>","title":"Flag"},{"location":"flags/#iteration","text":"","title":"Iteration"},{"location":"flags/#length","text":"Flag members know the number of bits in them: >>> len ( RWX ) 3","title":"Length"},{"location":"flags/#non-zero-checks","text":"Calling bool on the Flag member can be used to check if the member is non-zero: >>> bool ( RW ) True >>> bool ( N ) False","title":"Non-Zero Checks"},{"location":"flags/#container-checks","text":"Flags can check if the member belongs to another member: >>> P . R in RW True >>> P . N in RWX False","title":"Container Checks"},{"location":"flags/#intflag","text":"IntFlag is a flag derived from Flag and int , which allows its members to act as integers: class Color ( IntFlag ): RED = 1 GREEN = 2 BLUE = 4 red = Color . RED # <Color.RED: 1> value = red + 2 # 3 Note how members also lose their membership when int operations are applied. IntFlag members can be combined with integer values (compared to Flag which only supports checking members): red = Color . RED # <Color.RED: 1> red_blue = red | 4 # <Color.RED|BLUE: 4>","title":"IntFlag"},{"location":"security/","text":"Security Policy Reporting Thank you for taking the time to responsibly disclose any problems you find. Do not file public issues as they are open for everyone to see! All security vulnerabilities in enum-extensions should be reported by email to security@nekit.dev . Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report. You can encrypt your report using our public key: BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A . This key is also available on MIT's Key Server and reproduced below . After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours. Disclosure Policy enum-extensions has a 5-step disclosure process: The security report is received and is assigned a primary handler. This person will coordinate the fix and release process. The problem is confirmed and a list of all affected versions is determined. Code is audited to find any potential similar problems. Fixes are prepared for all releases which are still under maintenance. These fixes are not committed to the public repository but rather held locally pending the announcement. On the embargo date, the changes are pushed to the public repository and new builds are deployed. This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner. Security Key -----BEGIN PGP PUBLIC KEY BLOCK----- mQINBGKJEuEBEAC37iPX5u8sN+DZQ8c4Of+85u/hboSqNLp7VtTGgr/d8RCFhGZk 25ZwqGWeJbhnlPuzT6u96CZFRe3TMHYJR+A2NZBVjAQQjDRGbIGgaS6/9lvMLcRx D+hFQNPgwUTfPhSHIan+9EuYK/Bz+jyyIplwTrIBq1Mo0NG+cUNvAB+he22xhBQ7 y/Xal+sapHfYedqywhYEQUgP94IGURIMiBlAB7nKW+qs7YiQBShBbfxxffMgK6W6 sNNSybUQDqjj1AWkOBj5uizkA6FLF80xULypbhe1gbqsIt4d1Lj/mxI5zvj84wy5 oQ6QOpYlBUQwl8kqfszYaqKCviflA+riAFMAE8NVL+5BuVN0QSvQb6cRzIV1SL0p MCA6s2+plK/9K+JyR5yyjY7FxvatYNLW5LsubmS+YeBdO4l4A7YEElOGMexUb61H 3ejlb/9UUrZ7hd09Hsi1J6nthrI26o0XBdB8UJ9QAdfoHWka3fgSgopBBcI+S3tU iWGngFrUhiXcBS+0xHjrk4USKwFyFr8fmL4Y8Yu31ViHRFj6gVjC/PHP0apCnakB UEEMHnAQfztodH9o2ew2kew77+q9VblDGpb3BYaiptl4c6h6WBcEULpRfWERfB8H St4L49Ob6CCNpVw9qgsDfNw2fFjUIsT6OGwJxhv9StIFW2JEhgxEvfHr1wARAQAB tC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2 PokCUgQTAQgAPAIbAwIXgAIeBxYhBLstgZRGQAHgubYOuHQaHq0g/96KBQJiiR6G BQsJCAcCAyICAQYVCgkICwIEFgIDAQAKCRB0Gh6tIP/einfmD/9y69eqwjRfdmnW s0ph8Rh99JHtgA+zm1akRl+eymiqLuJwmZge7PPFb68Wj4lI6s1M1dIkyRuYMtIM 3rEcMmGUlcVnPldx/wdcPyhYZDUXnYCK64dsloftrWFWoSr5a/AILyVh/L6Fkf+L RU9h3KPMXhLTyK127ZF5WuzpjSJms0hDMDV/idfiDeWn/VGaZz1Wiks4l8R9kisR LI3RKNR537f0KFS8jkqlI41Lj9XQTUdqMRp+eqi/zUMM7OZzKQg1ohDsLi4MR6wa bXIu7LeAp1M0XlB+MO09KOxR8i19ST89EapAp4gHprbG5hJyV3XHK4txcWHG0YjB g5/fOvytljf/ue5YGe5nQUcxucq6i4d6jsB66Gk/4nnKutlMG2ZtVyIZZZActPZ5 qKI64HQJOpag+ERXwrv0optEhTC7RHOFRuZ4pCKuVjdJE9W7ZpAIAi8yHeVvpgJY glo+DqZH1/kLD1u2Jb/8yUuMeCYc3aBlfZswO6IeMFeXbPaMtIHzY5q7blIdKIAb YxS5KCYn8VHG6Nz8lFMu2z4jpH4QY9vTaxZnG3Xp23uxbP0pznih4DMiHIACyCBP WgRReZTCVU6Z9FvBq8t/hcrwli33lTa5hkuuzqcojn80+1g9st7DOzxVFtR2MoSS Wkv8ss8apRyeLNZAM5M8v+AiiyVCrLkCDQRiiRLhARAApEJFgvQVDMYpuo754cRK WC/17DH1BQ9y78h/0MXmOOf/0MpzJBkPjn4++BdXQGoOCBleHrWmbtmfYLcQFmZ/ eiUzxFDS/pkC7aZUb+YA7JzcwZQP2yOhlMfFK0qCoQKw/45q+AkOUR+Z+VGExkM1 5+PAcQ+7cQRiyina6/MG7FHAOcvuEwjiyt/0zBm3izeWmXL0Gngisl1jvd8bGn4T bK68q2d09NNHdXJ9UDFdGJ+FVIqJCyLyBl0ZfWazSkD/4ZNchdjFcSOzTTMvqWWn 6i5awbVyMPZkKS88vRVwTtcjk4+hrzaIyNbTw7y55qQxFe0NEoj4SK+iMwCkax19 njGQeB8GqmieC+0WYUSt10xXZ6tDf6a9F2cg6zv1ZklOuYU9x8GYwU7zvhrGhvXU Un1ZtP/OaHoQsS/+AS7KJtm/NWHGsfjd8vwDirIoZ31D7X52QrN07NQ0H7+uqtDL c7BAhsLI1G/r9Kz0+P0nC/6bMWvQWiomB1BSwUTfXLkT0RoKZ3Yub8XMk46N9XKE RtTk5x0/rZ40uOg8wzT1GvwYFA4tpavAqLejOftE05lKXAb5tQhYRupZywzXM6HN DR7CbP1e26g0p8GAuz1aFny6cN8T3wTHHyYn7aQk7i1BboV8zFpVlF6EmoHNCZtG hkl28kYa0Yvu+9mw0SPNiIsAEQEAAYkCNgQYAQgAIBYhBLstgZRGQAHgubYOuHQa Hq0g/96KBQJiiRLhAhsMAAoJEHQaHq0g/96KeCoP/3i3A629wvjPn7m3y7pTcV8p riTlH5OeXhg4jCORgJrgL4PSoeFCITA0u0djtcvctmCrHMsZe0hyH5+X+/B9Bsf6 eFQKWXLidqkxD/M6lnE6t34d17DvaWCP27MsS/f0u0FsLom11TTFgp4wGKZfRBNH vX5xuhjoYXYwZwWqCYyEXFTbsUTDce2oaqc7Yw/GmM3fCodLX0/0eYh5u2fiKA57 7VuUWD74/TkgcEOMa/IZ/jPmJHuHOteaIJR0pYUvLQ1EJh3jI4LhmH8DqxoUrmKy 8z2VM0iLIiev86EXM+yzqTpRIFnm6Ts+47L18rb9D5IUo68gr5B2bMKPOfvMVzdN /vw2RKdCVJ70nh3qqRis5RsJrn/3T8H1CQtuPvsAd/oB86YGWPpWBtpTyI+VBp+x +XR434K8D9QXFst73wTCnQwSX6j0sIotQC5GsPJEKky2Wijg3BlxqTxtYjLhwKWg x3e63TEw7IgU+lE/ybzWLJ7EndbKsC7stZh+Lyh5b3YHgI3cfJUxjZNFpniKr/Fy 4EjjLZzFf3QRmNNJ/7VlYLYztGZsOWxRsLk7QfUPSZY4iHUr8aiwfL7IFwnAlzIo 36HDjJi80UakMlf45UcxRaJwWiaj7G4x3h1D1BZLtMiypiaw/mesrithmfHg+KYu 1oYi7ft0FnZ67Wnk5+E+ =VRe2 -----END PGP PUBLIC KEY BLOCK----- Attribution This Security Policy is adapted from Rust's Security Policy .","title":"Security"},{"location":"security/#security-policy","text":"","title":"Security Policy"},{"location":"security/#reporting","text":"Thank you for taking the time to responsibly disclose any problems you find. Do not file public issues as they are open for everyone to see! All security vulnerabilities in enum-extensions should be reported by email to security@nekit.dev . Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report. You can encrypt your report using our public key: BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A . This key is also available on MIT's Key Server and reproduced below . After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.","title":"Reporting"},{"location":"security/#disclosure-policy","text":"enum-extensions has a 5-step disclosure process: The security report is received and is assigned a primary handler. This person will coordinate the fix and release process. The problem is confirmed and a list of all affected versions is determined. Code is audited to find any potential similar problems. Fixes are prepared for all releases which are still under maintenance. These fixes are not committed to the public repository but rather held locally pending the announcement. On the embargo date, the changes are pushed to the public repository and new builds are deployed. This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.","title":"Disclosure Policy"},{"location":"security/#security-key","text":"-----BEGIN PGP PUBLIC KEY BLOCK----- mQINBGKJEuEBEAC37iPX5u8sN+DZQ8c4Of+85u/hboSqNLp7VtTGgr/d8RCFhGZk 25ZwqGWeJbhnlPuzT6u96CZFRe3TMHYJR+A2NZBVjAQQjDRGbIGgaS6/9lvMLcRx D+hFQNPgwUTfPhSHIan+9EuYK/Bz+jyyIplwTrIBq1Mo0NG+cUNvAB+he22xhBQ7 y/Xal+sapHfYedqywhYEQUgP94IGURIMiBlAB7nKW+qs7YiQBShBbfxxffMgK6W6 sNNSybUQDqjj1AWkOBj5uizkA6FLF80xULypbhe1gbqsIt4d1Lj/mxI5zvj84wy5 oQ6QOpYlBUQwl8kqfszYaqKCviflA+riAFMAE8NVL+5BuVN0QSvQb6cRzIV1SL0p MCA6s2+plK/9K+JyR5yyjY7FxvatYNLW5LsubmS+YeBdO4l4A7YEElOGMexUb61H 3ejlb/9UUrZ7hd09Hsi1J6nthrI26o0XBdB8UJ9QAdfoHWka3fgSgopBBcI+S3tU iWGngFrUhiXcBS+0xHjrk4USKwFyFr8fmL4Y8Yu31ViHRFj6gVjC/PHP0apCnakB UEEMHnAQfztodH9o2ew2kew77+q9VblDGpb3BYaiptl4c6h6WBcEULpRfWERfB8H St4L49Ob6CCNpVw9qgsDfNw2fFjUIsT6OGwJxhv9StIFW2JEhgxEvfHr1wARAQAB tC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2 PokCUgQTAQgAPAIbAwIXgAIeBxYhBLstgZRGQAHgubYOuHQaHq0g/96KBQJiiR6G BQsJCAcCAyICAQYVCgkICwIEFgIDAQAKCRB0Gh6tIP/einfmD/9y69eqwjRfdmnW s0ph8Rh99JHtgA+zm1akRl+eymiqLuJwmZge7PPFb68Wj4lI6s1M1dIkyRuYMtIM 3rEcMmGUlcVnPldx/wdcPyhYZDUXnYCK64dsloftrWFWoSr5a/AILyVh/L6Fkf+L RU9h3KPMXhLTyK127ZF5WuzpjSJms0hDMDV/idfiDeWn/VGaZz1Wiks4l8R9kisR LI3RKNR537f0KFS8jkqlI41Lj9XQTUdqMRp+eqi/zUMM7OZzKQg1ohDsLi4MR6wa bXIu7LeAp1M0XlB+MO09KOxR8i19ST89EapAp4gHprbG5hJyV3XHK4txcWHG0YjB g5/fOvytljf/ue5YGe5nQUcxucq6i4d6jsB66Gk/4nnKutlMG2ZtVyIZZZActPZ5 qKI64HQJOpag+ERXwrv0optEhTC7RHOFRuZ4pCKuVjdJE9W7ZpAIAi8yHeVvpgJY glo+DqZH1/kLD1u2Jb/8yUuMeCYc3aBlfZswO6IeMFeXbPaMtIHzY5q7blIdKIAb YxS5KCYn8VHG6Nz8lFMu2z4jpH4QY9vTaxZnG3Xp23uxbP0pznih4DMiHIACyCBP WgRReZTCVU6Z9FvBq8t/hcrwli33lTa5hkuuzqcojn80+1g9st7DOzxVFtR2MoSS Wkv8ss8apRyeLNZAM5M8v+AiiyVCrLkCDQRiiRLhARAApEJFgvQVDMYpuo754cRK WC/17DH1BQ9y78h/0MXmOOf/0MpzJBkPjn4++BdXQGoOCBleHrWmbtmfYLcQFmZ/ eiUzxFDS/pkC7aZUb+YA7JzcwZQP2yOhlMfFK0qCoQKw/45q+AkOUR+Z+VGExkM1 5+PAcQ+7cQRiyina6/MG7FHAOcvuEwjiyt/0zBm3izeWmXL0Gngisl1jvd8bGn4T bK68q2d09NNHdXJ9UDFdGJ+FVIqJCyLyBl0ZfWazSkD/4ZNchdjFcSOzTTMvqWWn 6i5awbVyMPZkKS88vRVwTtcjk4+hrzaIyNbTw7y55qQxFe0NEoj4SK+iMwCkax19 njGQeB8GqmieC+0WYUSt10xXZ6tDf6a9F2cg6zv1ZklOuYU9x8GYwU7zvhrGhvXU Un1ZtP/OaHoQsS/+AS7KJtm/NWHGsfjd8vwDirIoZ31D7X52QrN07NQ0H7+uqtDL c7BAhsLI1G/r9Kz0+P0nC/6bMWvQWiomB1BSwUTfXLkT0RoKZ3Yub8XMk46N9XKE RtTk5x0/rZ40uOg8wzT1GvwYFA4tpavAqLejOftE05lKXAb5tQhYRupZywzXM6HN DR7CbP1e26g0p8GAuz1aFny6cN8T3wTHHyYn7aQk7i1BboV8zFpVlF6EmoHNCZtG hkl28kYa0Yvu+9mw0SPNiIsAEQEAAYkCNgQYAQgAIBYhBLstgZRGQAHgubYOuHQa Hq0g/96KBQJiiRLhAhsMAAoJEHQaHq0g/96KeCoP/3i3A629wvjPn7m3y7pTcV8p riTlH5OeXhg4jCORgJrgL4PSoeFCITA0u0djtcvctmCrHMsZe0hyH5+X+/B9Bsf6 eFQKWXLidqkxD/M6lnE6t34d17DvaWCP27MsS/f0u0FsLom11TTFgp4wGKZfRBNH vX5xuhjoYXYwZwWqCYyEXFTbsUTDce2oaqc7Yw/GmM3fCodLX0/0eYh5u2fiKA57 7VuUWD74/TkgcEOMa/IZ/jPmJHuHOteaIJR0pYUvLQ1EJh3jI4LhmH8DqxoUrmKy 8z2VM0iLIiev86EXM+yzqTpRIFnm6Ts+47L18rb9D5IUo68gr5B2bMKPOfvMVzdN /vw2RKdCVJ70nh3qqRis5RsJrn/3T8H1CQtuPvsAd/oB86YGWPpWBtpTyI+VBp+x +XR434K8D9QXFst73wTCnQwSX6j0sIotQC5GsPJEKky2Wijg3BlxqTxtYjLhwKWg x3e63TEw7IgU+lE/ybzWLJ7EndbKsC7stZh+Lyh5b3YHgI3cfJUxjZNFpniKr/Fy 4EjjLZzFf3QRmNNJ/7VlYLYztGZsOWxRsLk7QfUPSZY4iHUr8aiwfL7IFwnAlzIo 36HDjJi80UakMlf45UcxRaJwWiaj7G4x3h1D1BZLtMiypiaw/mesrithmfHg+KYu 1oYi7ft0FnZ67Wnk5+E+ =VRe2 -----END PGP PUBLIC KEY BLOCK-----","title":"Security Key"},{"location":"security/#attribution","text":"This Security Policy is adapted from Rust's Security Policy .","title":"Attribution"},{"location":"traits/","text":"Traits enum-extensions implements special traits (aka mixins ), which add specific behavior to enumerations. Each Trait implements some functionality for enumerations, but does not subclass Enum directly. Prerequisites Code snippets and examples below are using several common imports and types, which are mainly omitted for simplicity: from enum_extensions import ( # library imports used in examples # enumerations Enum , # traits Trait , Order , Format , Title , # auto items auto , ) Ordering Order implements ordering ( < , > , <= , >= ) for enumerations: class Grade ( Order , Enum ): A = 5 B = 4 C = 3 D = 2 F = 1 >>> Grade . F < Grade . D True >>> Grade . A > Grade . B True >>> Grade . C <= Grade . C True >>> Grade . B >= Grade . B True Formatting Format Titles Title Defining Traits One can define custom traits to use, for instance: class StringTitle ( Trait ): \"\"\"Use the title of the member as its string representation.\"\"\" def __str__ ( self ) -> str : return self . title_name Deriving from this new trait: class Color ( StringTitle , Enum ): RED = auto () GREEN = auto () BLUE = auto () Gives the expected result: >>> print ( Color . RED ) Red","title":"Traits"},{"location":"traits/#traits","text":"enum-extensions implements special traits (aka mixins ), which add specific behavior to enumerations. Each Trait implements some functionality for enumerations, but does not subclass Enum directly.","title":"Traits"},{"location":"traits/#prerequisites","text":"Code snippets and examples below are using several common imports and types, which are mainly omitted for simplicity: from enum_extensions import ( # library imports used in examples # enumerations Enum , # traits Trait , Order , Format , Title , # auto items auto , )","title":"Prerequisites"},{"location":"traits/#ordering","text":"Order implements ordering ( < , > , <= , >= ) for enumerations: class Grade ( Order , Enum ): A = 5 B = 4 C = 3 D = 2 F = 1 >>> Grade . F < Grade . D True >>> Grade . A > Grade . B True >>> Grade . C <= Grade . C True >>> Grade . B >= Grade . B True","title":"Ordering"},{"location":"traits/#formatting","text":"Format","title":"Formatting"},{"location":"traits/#titles","text":"Title","title":"Titles"},{"location":"traits/#defining-traits","text":"One can define custom traits to use, for instance: class StringTitle ( Trait ): \"\"\"Use the title of the member as its string representation.\"\"\" def __str__ ( self ) -> str : return self . title_name Deriving from this new trait: class Color ( StringTitle , Enum ): RED = auto () GREEN = auto () BLUE = auto () Gives the expected result: >>> print ( Color . RED ) Red","title":"Defining Traits"},{"location":"reference/auto/","text":"Auto Bases: Generic [ T ] Instances are replaced with an appropriate generated value in Enum classes. Source code in enum_extensions/auto.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Auto ( Generic [ T ]): \"\"\"Instances are replaced with an appropriate generated value in [`Enum`][enum_extensions.enums.Enum] classes. \"\"\" def __init__ ( self , value : Nullable [ T ] = null ) -> None : self . _value = value @property def value ( self ) -> Nullable [ T ]: \"\"\"The wrapped value.\"\"\" return self . _value @value . setter def value ( self , value : Nullable [ T ]) -> None : \"\"\"The wrapped value.\"\"\" self . _value = value value () property writable The wrapped value. Source code in enum_extensions/auto.py 21 22 23 24 25 @property def value ( self ) -> Nullable [ T ]: \"\"\"The wrapped value.\"\"\" return self . _value auto ( auto_type = AnyAuto ) Creates an Auto instance. Example class Test ( Enum , start = 13 ): TEST = auto () # <- used here test = Test . TEST # <Test.TEST: 13> <- an appropriate generated value This function simply calls auto_type() to create an appropriate instance. Parameters: Name Type Description Default auto_type Type [ AnyAuto ] The Auto type to use. AnyAuto Returns: Type Description AnyAuto A newly created Auto instance. Source code in enum_extensions/auto.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def auto ( auto_type : Type [ AnyAuto ] = AnyAuto ) -> AnyAuto : \"\"\"Creates an [`Auto`][enum_extensions.auto.Auto] instance. Example: ```python class Test(Enum, start=13): TEST = auto() # <- used here test = Test.TEST # <Test.TEST: 13> <- an appropriate generated value ``` This function simply calls `auto_type()` to create an appropriate instance. Arguments: auto_type: The [`Auto`][enum_extensions.auto.Auto] type to use. Returns: A newly created [`Auto`][enum_extensions.auto.Auto] instance. \"\"\" return auto_type () is_auto ( item ) Checks if an item is an instance of Auto . Example assert is_auto ( auto ()) assert not is_auto ( 42 ) Parameters: Name Type Description Default item MaybeAuto [ T ] An instance to check. required Returns: Type Description TypeGuard [ Auto [ T ]] Whether an item is an instance of Auto . Source code in enum_extensions/auto.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def is_auto ( item : MaybeAuto [ T ]) -> TypeGuard [ Auto [ T ]]: \"\"\"Checks if an `item` is an instance of [`Auto`][enum_extensions.auto.Auto]. Example: ```python assert is_auto(auto()) assert not is_auto(42) ``` Arguments: item: An instance to check. Returns: Whether an item is an instance of [`Auto`][enum_extensions.auto.Auto]. \"\"\" return is_instance ( item , Auto )","title":"Auto"},{"location":"reference/auto/#enum_extensions.auto.Auto","text":"Bases: Generic [ T ] Instances are replaced with an appropriate generated value in Enum classes. Source code in enum_extensions/auto.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Auto ( Generic [ T ]): \"\"\"Instances are replaced with an appropriate generated value in [`Enum`][enum_extensions.enums.Enum] classes. \"\"\" def __init__ ( self , value : Nullable [ T ] = null ) -> None : self . _value = value @property def value ( self ) -> Nullable [ T ]: \"\"\"The wrapped value.\"\"\" return self . _value @value . setter def value ( self , value : Nullable [ T ]) -> None : \"\"\"The wrapped value.\"\"\" self . _value = value","title":"Auto"},{"location":"reference/auto/#enum_extensions.auto.Auto.value","text":"The wrapped value. Source code in enum_extensions/auto.py 21 22 23 24 25 @property def value ( self ) -> Nullable [ T ]: \"\"\"The wrapped value.\"\"\" return self . _value","title":"value()"},{"location":"reference/auto/#enum_extensions.auto.auto","text":"Creates an Auto instance. Example class Test ( Enum , start = 13 ): TEST = auto () # <- used here test = Test . TEST # <Test.TEST: 13> <- an appropriate generated value This function simply calls auto_type() to create an appropriate instance. Parameters: Name Type Description Default auto_type Type [ AnyAuto ] The Auto type to use. AnyAuto Returns: Type Description AnyAuto A newly created Auto instance. Source code in enum_extensions/auto.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def auto ( auto_type : Type [ AnyAuto ] = AnyAuto ) -> AnyAuto : \"\"\"Creates an [`Auto`][enum_extensions.auto.Auto] instance. Example: ```python class Test(Enum, start=13): TEST = auto() # <- used here test = Test.TEST # <Test.TEST: 13> <- an appropriate generated value ``` This function simply calls `auto_type()` to create an appropriate instance. Arguments: auto_type: The [`Auto`][enum_extensions.auto.Auto] type to use. Returns: A newly created [`Auto`][enum_extensions.auto.Auto] instance. \"\"\" return auto_type ()","title":"auto()"},{"location":"reference/auto/#enum_extensions.auto.is_auto","text":"Checks if an item is an instance of Auto . Example assert is_auto ( auto ()) assert not is_auto ( 42 ) Parameters: Name Type Description Default item MaybeAuto [ T ] An instance to check. required Returns: Type Description TypeGuard [ Auto [ T ]] Whether an item is an instance of Auto . Source code in enum_extensions/auto.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def is_auto ( item : MaybeAuto [ T ]) -> TypeGuard [ Auto [ T ]]: \"\"\"Checks if an `item` is an instance of [`Auto`][enum_extensions.auto.Auto]. Example: ```python assert is_auto(auto()) assert not is_auto(42) ``` Arguments: item: An instance to check. Returns: Whether an item is an instance of [`Auto`][enum_extensions.auto.Auto]. \"\"\" return is_instance ( item , Auto )","title":"is_auto()"},{"location":"reference/enums/","text":"EnumDict Bases: Namespace Tracks enumeration members and ensures their names are not reused. Source code in enum_extensions/enums.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 class EnumDict ( Namespace ): \"\"\"Tracks enumeration members and ensures their names are not reused.\"\"\" def __init__ ( self ) -> None : self . _generate_next_value : Optional [ GenerateNextValue [ Any ]] = None self . _start : Optional [ Any ] = None self . _ignore : Set [ str ] = set () self . _member_names : List [ str ] = [] self . _member_values : List [ Any ] = [] self . _mapping : StringDict [ Any ] = {} super () . __init__ () @property def generate_next_value ( self ) -> Optional [ GenerateNextValue [ Any ]]: return self . _generate_next_value @property def start ( self ) -> Optional [ Any ]: return self . _start @property def ignore ( self ) -> Set [ str ]: return self . _ignore def _set_generate_next_value ( self , generate_next_value : Optional [ GenerateNextValue [ Any ]] ) -> None : self . _generate_next_value = generate_next_value def _set_start ( self , start : Optional [ Any ]) -> None : self . _start = start def _set_ignore ( self , ignore : MaybeIterable [ str ]) -> None : if is_string ( ignore ): self . _ignore = set ( ignore . replace ( COMMA , SPACE ) . strip () . split ()) else : self . _ignore = set ( ignore ) @property def member_names ( self ) -> List [ str ]: return self . _member_names @property def member_values ( self ) -> List [ Any ]: return self . _member_values @property def mapping ( self ) -> StringDict [ Any ]: return self . _mapping def is_used ( self , name : str ) -> bool : return name in self def is_ignored ( self , name : str ) -> bool : return name in self . ignore def is_reserved ( self , name : str ) -> bool : return name in self . mapping def add_member ( self , name : str , value : MaybeAuto [ Any ]) -> None : if is_auto ( value ): if is_null ( value . value ): generate_next_value = self . generate_next_value if generate_next_value is None : raise RuntimeError ( CAN_NOT_USE_AUTO ) value . value = generate_next_value ( name , self . start , len ( self . member_names ), self . member_values . copy () ) value = value . value self . mapping [ name ] = value self . member_names . append ( name ) self . member_values . append ( value ) def __setitem__ ( self , name : str , value : Any ) -> None : if name == ENUM_GENERATE_NEXT_VALUE : self . _set_generate_next_value ( value ) elif name == ENUM_IGNORE : self . _set_ignore ( value ) elif name == ENUM_START : self . _set_start ( value ) elif self . is_reserved ( name ): raise ValueError ( ATTEMPT_TO_REUSE . format ( tick ( name ))) elif is_member ( value ): value = value . value self . add_member ( name , value ) elif is_non_member ( value ): value = value . value elif self . is_ignored ( name ) or is_double_under_name ( name ) or is_descriptor ( value ): pass elif self . is_used ( name ): raise ValueError ( ALREADY_DEFINED . format ( tick ( name ))) else : self . add_member ( name , value ) super () . __setitem__ ( name , value ) def update ( self , item : Union [ StringMapping [ Any ], StringPairs [ Any ]] = (), ** items : Any ) -> None : if is_mapping ( item ): for name , value in item . items (): self [ name ] = value else : for name , value in item : self [ name ] = value for name , value in items . items (): self [ name ] = value EnumType Bases: type Metaclass for Enum . EnumType is responsible for setting the correct methods on the final enumeration , as well as creating its members , properly handling duplicates, providing iteration over the enumeration members, etc. Source code in enum_extensions/enums.py 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 class EnumType ( type ): \"\"\"Metaclass for [`Enum`][enum_extensions.enums.Enum]. [`EnumType`][enum_extensions.enums.EnumType] is responsible for setting the correct methods on the final *enumeration*, as well as creating its *members*, properly handling duplicates, providing iteration over the enumeration members, etc. \"\"\" _unknown : bool _flag : bool _start : Optional [ Any ] _member_names : List [ str ] _member_values : List [ Any ] _data_type : AnyType _new_function : DynamicCallable [ Any ] _new_use_args : bool _member_mapping : StringDict [ Enum ] _value_mapping : Dict [ Any , Enum ] _dynamic_attributes : Set [ str ] @classmethod def __prepare__ ( cls , name : str , bases : DynamicTuple [ AnyType ], * , ignore : Optional [ MaybeIterable [ str ]] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , flag : bool = False , ** kwargs : Any , ) -> EnumDict : namespace = EnumDict () enum_type = find_enum_type ( bases ) if ignore is None : ignore = () namespace . update ( enum_generate_next_value = get_attribute ( enum_type , ENUM_GENERATE_NEXT_VALUE , None ), enum_ignore = ignore , enum_start = start , ) return namespace def __new__ ( cls : Type [ ET ], enum_name : str , bases : DynamicTuple [ AnyType ], namespace : EnumDict , * , ignore : Optional [ MaybeIterable [ str ]] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , flag : bool = False , ** kwargs : Any , ) -> ET : global ENUM_DEFINED # add `enum_ignore` to itself enum_ignore = namespace . ignore enum_ignore . add ( ENUM_IGNORE ) # remove all names in `enum_ignore` for name in enum_ignore : if name in namespace : del namespace [ name ] enum_type = find_enum_type ( bases ) # type: ignore if enum_type is None and ENUM_DEFINED : # pragma: no cover enum_type = Enum data_type = find_data_type ( bases ) new = find_new ( namespace , data_type , enum_type ) enum_members = namespace . mapping . copy () # remove enum members so they do not get into new enum type for name in namespace . member_names : if name in namespace : del namespace [ name ] # check for invalid names invalid_names = set ( enum_members ) & INVALID_NAMES if invalid_names : names = concat_comma_space ( map ( tick , invalid_names )) raise ValueError ( INVALID_MEMBER_NAMES . format ( names )) namespace . setdefault ( DOCUMENTATION , ENUM_DOCUMENTATION ) # handle reduce if REDUCE not in namespace : if data_type is not object : pickle_methods = set ( vars ( data_type )) & PICKLE_METHODS if not pickle_methods : make_namespace_unpicklable ( namespace ) # create dummy enum type dummy_enum_type = super () . __new__ ( cls , enum_name , bases , EnumDict ()) # manipulate Method Resolution Order (MRO) mro = list ( dummy_enum_type . mro ()) try : mro . remove ( dummy_enum_type ) except ValueError : # pragma: no cover pass try : if mro . index ( data_type ) < mro . index ( enum_type ): # we need to preserve enum_type functions mro . remove ( enum_type ) mro . insert ( mro . index ( data_type ), enum_type ) except ValueError : # pragma: no cover pass bases = tuple ( mro ) # now back to tuple # create new enum type new_enum_type = super () . __new__ ( cls , enum_name , bases , namespace ) # on top of it, preserve names that should ideally belong to enums for name in ENUM_PRESERVE : if name in namespace : continue type_method = get_attribute ( new_enum_type , name ) data_method = get_attribute ( data_type , name , None ) enum_method = get_attribute ( enum_type , name , None ) if data_method is not None and data_method is type_method : set_attribute ( new_enum_type , name , enum_method ) # add information new_enum_type . _flag = flag new_enum_type . _start = namespace . start new_enum_type . _member_names = [] new_enum_type . _member_values = [] new_enum_type . _data_type = data_type new_enum_type . _new_function = new . function new_enum_type . _new_use_args = new . use_args # add mappings new_enum_type . _member_mapping = {} # name -> member new_enum_type . _value_mapping = {} # value -> member (if hashable) if unknown is None : unknown = get_attribute ( new_enum_type , UNKNOWN_PRIVATE , False ) new_enum_type . _unknown = unknown # save dynamic attributes to know if we an take the shortcut of # storing members in the type dict dynamic_attributes = { name for type in new_enum_type . mro () for name , value in vars ( type ) . items () if is_instance ( value , dynamic_attribute ) } new_enum_type . _dynamic_attributes = dynamic_attributes # create fellow enum members for name , value in enum_members . items (): create_enum_member ( name , value , data_type , new_enum_type , new . function , new . use_args , dynamic_attributes , flag , ) # save new if needed if ENUM_DEFINED : if new . save : new_enum_type . __new_member__ = new . function new_enum_type . __new__ = Enum . __new__ else : ENUM_DEFINED = True return new_enum_type @overload def __call__ ( self : Type [ E ], value : Any ) -> E : ... @overload def __call__ ( self : ET , value : str , names : Optional [ Names ] = ... , * , module : Optional [ str ] = ... , qualified_name : Optional [ str ] = ... , type : Optional [ AnyType ] = ... , start : Optional [ Any ] = ... , unknown : Optional [ bool ] = ... , ** members : Any , ) -> ET : ... def __call__ ( self : Type [ E ], value : Any , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , ** members : Any , ) -> Union [ E , Type [ E ]]: \"\"\"Looks up an existing member or creates a new enumeration. Example: Creation: ```python Color = Enum(\"Color\", RED=1, GREEN=2, BLUE=3) ``` Value lookup: ```python green = Color(2) # <Color.GREEN: 2> ``` Arguments: value: The value to search for or the name of the new [`Enum`][enum_extensions.enums.Enum] to create. names: The names/values of the new enumeration members. module: The name of the module the [`Enum`][enum_extensions.enums.Enum] is created in. qualified_name: The actual location in the module where the enumeration can be found. type: A data type of the new [`Enum`][enum_extensions.enums.Enum]. start: The initial value of the new enumeration (used by [`auto`][enum_extensions.auto.auto]). unknown: Whether to enable unknown values of enumeration members. [`None`][None] means that it should be inherited. The default value in the end is [`False`][False]. **members: A `name -> value` mapping of [`Enum`][enum_extensions.enums.Enum] members. Raises: ValueError: The member was not found. ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] type or a member found. \"\"\" if names or module or qualified_name or type or start or unknown or members : return self . create ( value , names , module = module , qualified_name = qualified_name , type = type , start = start , unknown = unknown , direct_call = False , ** members , ) return self . __new__ ( self , value ) def create ( self : ET , enum_name : str , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , direct_call : bool = True , ** members : Any , ) -> ET : \"\"\"Creates a new enumeration. Example: ```python Color = Enum(\"Color\", (\"RED\", \"GREEN\", \"BLUE\")) ``` Arguments: enum_name: The name of the new [`Enum`][enum_extensions.enums.Enum] to create. names: The names/values of the new enumeration members. module: The name of the module the [`Enum`][enum_extensions.enums.Enum] is created in. qualified_name: The actual location in the module where the enumeration can be found. type: A data type of the new [`Enum`][enum_extensions.enums.Enum]. start: The initial value of the new enumeration (used by [`auto`][enum_extensions.auto.auto]). unknown: Whether to enable unknown values of enumeration members. [`None`][None] means that it should be deduced from inheritance. The default value in the end is [`False`][False]. direct_call: Controls if the function is called directly or not. Use this argument with caution. **members: A `name -> value` mapping of [`Enum`][enum_extensions.enums.Enum] members. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] type. \"\"\" meta = standard_type ( self ) bases = ( self ,) if type is None else ( type , self ) enum_type = find_enum_type ( bases ) namespace = meta . __prepare__ ( enum_name , bases , start = start , unknown = unknown ) if names is not None : # special processing needed for strings if is_string ( names ): names = names . replace ( COMMA , SPACE ) . strip () . split () if is_mapping ( names ): namespace . update ( names ) else : iterator = iter ( names ) item = next ( iterator , null ) if is_not_null ( item ): iterator = prepend ( item , iterator ) if is_string ( item ): original_names , names = names , [] values = [] for count , name in enumerate ( original_names ): value = enum_type . enum_generate_next_value ( name , start , count , values . copy () ) values . append ( value ) names . append (( name , value )) iterator = iter ( names ) namespace . update ( iterator ) namespace . update ( members ) # TODO: replace the frame hack if a blessed way to know the calling # module is ever developed if module is None : try : module = get_frame ( DIRECT_CALLER if direct_call else NESTED_CALLER ) . f_globals [ NAME ] except ( AttributeError , ValueError , KeyError ): # pragma: no cover pass if module is None : # pragma: no cover make_namespace_unpicklable ( namespace ) else : namespace [ MODULE ] = module if qualified_name is None : if module is not None : qualified_name = QUALIFIED_NAME_STRING . format ( module , enum_name ) if qualified_name is not None : namespace [ QUALIFIED_NAME ] = qualified_name return meta . __new__ ( meta , enum_name , bases , namespace , unknown = unknown ) def is_empty ( self ) -> bool : \"\"\"Checks whether the enumeration does not contain any members. Example: ```python class Test(Enum): TEST = 42 assert Enum.is_empty() assert not Test.is_empty() ``` \"\"\" return not self . _member_values def add_member ( self : Type [ E ], name : Optional [ str ], value : Any ) -> E : \"\"\"Adds a new member to the enumeration. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 black = Color.add_member(\"BLACK\", 0) # <Color.BLACK: 0> ``` Arguments: name: The name of a member. value: The value of a member. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] member. \"\"\" if is_auto ( value ): if is_null ( value . value ): value . value = self . enum_generate_next_value ( name , self . _start , len ( self . _member_names ), self . _member_values . copy () ) value = value . value return create_enum_member ( name , value , self . _data_type , self , self . _new_function , self . _new_use_args , self . _dynamic_attributes , self . _flag , ) def update ( self : Type [ E ], ** name_to_value : Any ) -> None : \"\"\"Updates the enumeration, adding members to it. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 Color.update(BLACK=0, WHITE=4) colors = (Color.BLACK, Color.WHITE) # (<Color.BLACK: 0>, <Color.WHITE: 4>) ``` Arguments: **name_to_value: Keywords argument in `name -> value` form. Raises: ValueError: The name in `name_to_value` is already used by another member. \"\"\" for name , value in name_to_value . items (): self . add_member ( name , value ) def __bool__ ( self ) -> Literal [ True ]: return True def __contains__ ( self : Type [ E ], data : Any ) -> bool : \"\"\"Checks whether the `data` is in [`Enum`][enum_extensions.enums.Enum]. `data` is contained in enumeration if: - `data` is a member of said enumeration, or - `data` is the value of one of the members. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 assert Color.RED in Color assert 3 in Color assert 0 not in Color ``` Arguments: data: The data to check. Returns: Whether the `data` is contained in [`Enum`][enum_extensions.enums.Enum]. \"\"\" if is_instance ( data , self ): return True try : return data in self . _value_mapping except TypeError : return data in self . _member_values def __delattr__ ( self , name : str ) -> None : if name in self . _member_mapping : raise AttributeError ( CAN_NOT_DELETE_MEMBER . format ( tick ( name ))) super () . __delattr__ ( name ) def __getattr__ ( self : Type [ E ], name : str ) -> E : \"\"\"Returns the [`Enum`][enum_extensions.enums.Enum] member matching `name`. Example: ```python >>> Color.BLUE <Color.BLUE: 3> ``` Arguments: name: The name of the member to find. Raises: AttributeError: The member was not found. Returns: The member found. \"\"\" if is_double_under_name ( name ): raise AttributeError ( name ) try : return self . _member_mapping [ name ] except KeyError : raise AttributeError ( name ) from None def __getitem__ ( self : Type [ E ], name : str ) -> E : \"\"\"Returns the [`Enum`][enum_extensions.enums.Enum] member matching `name`. Example: ```python >>> Color[\"GREEN\"] <Color.GREEN: 2> ``` Arguments: name: The name of the member to find. Raises: KeyError: The member was not found. Returns: The member found. \"\"\" return self . _member_mapping [ name ] def __iter__ ( self : Type [ E ]) -> Iterator [ E ]: \"\"\"Returns an iterator over unique [`Enum`][enum_extensions.enums.Enum] members in definition order. Example: ```python >>> tuple(Color) (<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>) ``` Returns: An iterator of unique [`Enum`][enum_extensions.enums.Enum] members. \"\"\" return self . iter_members () def __reversed__ ( self : Type [ E ]) -> Iterator [ E ]: \"\"\"Returns an iterator over unique [`Enum`][enum_extensions.enums.Enum] members in reverse definition order. Example: ```python >>> tuple(reversed(Color)) (<Color.BLUE: 3>, <Color.GREEN: 2>, <Color.RED: 1>) ``` Returns: An iterator of unique [`Enum`][enum_extensions.enums.Enum] members. \"\"\" return self . iter_members ( reverse = True ) def __len__ ( self ) -> int : \"\"\"Returns the number of unique members (excluding aliases). Example: ```python >>> len(Color) 3 ``` Returns: The count of unique enumeration members. \"\"\" return len ( self . _member_names ) def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name. Example: ```python >>> Color <enum `Color`> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return ENUM_REPRESENTATION . format ( tick ( get_name ( self ))) def __setattr__ ( self , name : str , value : Any ) -> None : member_mapping = vars ( self ) . get ( MEMBER_MAPPING_PRIVATE , {}) # prevent recursion if name in member_mapping : raise AttributeError ( CAN_NOT_REASSIGN_MEMBER . format ( tick ( name ))) super () . __setattr__ ( name , value ) def iter_members ( self : Type [ E ], reverse : bool = False ) -> Iterator [ E ]: \"\"\"Returns an iterator over unique enumeration members in definition order, optionally reversing it. Example: ```python >>> list(Color.iter_members()) [<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>] >>> list(Color.iter_members(reverse=True)) [<Color.BLUE: 3>, <Color.GREEN: 2>, <Color.RED: 1>] ``` Arguments: reverse: Whether to reverse the definition order. Returns: An iterator over unique members. \"\"\" names = self . _member_names if reverse : names = reversed ( names ) member_mapping = self . _member_mapping return ( member_mapping [ name ] for name in names ) @property def members ( self : Type [ E ]) -> StringMapping [ E ]: \"\"\"An immutable mapping of enumeration members (including aliases). Example: ```python >>> for name, member in self.members.items(): ... print(name, member) RED Color.RED GREEN Color.GREEN BLUE Color.BLUE ``` Returns: An immutable mapping of all enumeration members. \"\"\" return MappingProxy ( self . _member_mapping ) __members__ = members @property def case_fold_names ( self : Type [ E ]) -> StringMapping [ E ]: return { case_fold_name ( name ): member for name , member in self . _member_mapping . items ()} def from_name ( self : Type [ E ], name : str ) -> E : \"\"\"Finds a member by name *case insensitively*. Example: ```python class Test(Enum): TEST = 13 test = Test.from_name(\"test\") # <Test.TEST: 13> ``` Arguments: name: The name to look up. Raises: KeyError: Member is not found. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" return self . case_fold_names [ case_fold_name ( name )] def from_value ( self : Type [ E ], value : Any , default : Nullable [ Any ] = null ) -> E : \"\"\"Finds a member by value with an optional `default` value fallback. Example: ```python class Test(Enum): TEST = 25 test = Test.from_value(25) # <Test.TEST: 25> ``` Arguments: value: The value to look up. default: The default value to fall back to. Raises: ValueError: Member is not found and `default` is not provided. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" try : return self ( value ) except ValueError : if is_null ( default ): raise return self ( default ) def from_data ( self : Type [ E ], data : Any , default : Nullable [ Any ] = null ) -> E : \"\"\"Finds a member by name or by value with an optional `default` value fallback. Example: ```python class Test(Enum): TEST = 42 test = Test.from_data(\"test\") # <Test.TEST: 42> test = Test.from_data(42) # <Test.TEST: 42> ``` Arguments: data: The name or value to look up. default: The default value to fall back to. Raises: ValueError: Member is not found and `default` is not provided. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" if is_string ( data ): try : return self . from_name ( data ) except KeyError : pass try : return self . from_value ( data ) except ValueError : if is_null ( default ): raise return self . from_data ( default ) def enum_missing ( self : Type [ E ], value : Any ) -> Optional [ E ]: if self . _unknown : return self . add_member ( None , value ) return None __call__ ( value , names = None , * , module = None , qualified_name = None , type = None , start = None , unknown = None , ** members ) Looks up an existing member or creates a new enumeration. Example Creation: Color = Enum ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 3 ) Value lookup: green = Color ( 2 ) # <Color.GREEN: 2> Parameters: Name Type Description Default value Any The value to search for or the name of the new Enum to create. required names Optional [ Names ] The names/values of the new enumeration members. None module Optional [ str ] The name of the module the Enum is created in. None qualified_name Optional [ str ] The actual location in the module where the enumeration can be found. None type Optional [ AnyType ] A data type of the new Enum . None start Optional [ Any ] The initial value of the new enumeration (used by auto ). None unknown Optional [ bool ] Whether to enable unknown values of enumeration members. None means that it should be inherited. The default value in the end is False . None **members Any A name -> value mapping of Enum members. {} Raises: Type Description ValueError The member was not found. ValueError The name is already used by another member. Returns: Type Description Union [ E , Type [ E ]] A newly created Enum type or a member found. Source code in enum_extensions/enums.py 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 def __call__ ( self : Type [ E ], value : Any , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , ** members : Any , ) -> Union [ E , Type [ E ]]: \"\"\"Looks up an existing member or creates a new enumeration. Example: Creation: ```python Color = Enum(\"Color\", RED=1, GREEN=2, BLUE=3) ``` Value lookup: ```python green = Color(2) # <Color.GREEN: 2> ``` Arguments: value: The value to search for or the name of the new [`Enum`][enum_extensions.enums.Enum] to create. names: The names/values of the new enumeration members. module: The name of the module the [`Enum`][enum_extensions.enums.Enum] is created in. qualified_name: The actual location in the module where the enumeration can be found. type: A data type of the new [`Enum`][enum_extensions.enums.Enum]. start: The initial value of the new enumeration (used by [`auto`][enum_extensions.auto.auto]). unknown: Whether to enable unknown values of enumeration members. [`None`][None] means that it should be inherited. The default value in the end is [`False`][False]. **members: A `name -> value` mapping of [`Enum`][enum_extensions.enums.Enum] members. Raises: ValueError: The member was not found. ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] type or a member found. \"\"\" if names or module or qualified_name or type or start or unknown or members : return self . create ( value , names , module = module , qualified_name = qualified_name , type = type , start = start , unknown = unknown , direct_call = False , ** members , ) return self . __new__ ( self , value ) create ( enum_name , names = None , * , module = None , qualified_name = None , type = None , start = None , unknown = None , direct_call = True , ** members ) Creates a new enumeration. Example Color = Enum ( \"Color\" , ( \"RED\" , \"GREEN\" , \"BLUE\" )) Parameters: Name Type Description Default enum_name str The name of the new Enum to create. required names Optional [ Names ] The names/values of the new enumeration members. None module Optional [ str ] The name of the module the Enum is created in. None qualified_name Optional [ str ] The actual location in the module where the enumeration can be found. None type Optional [ AnyType ] A data type of the new Enum . None start Optional [ Any ] The initial value of the new enumeration (used by auto ). None unknown Optional [ bool ] Whether to enable unknown values of enumeration members. None means that it should be deduced from inheritance. The default value in the end is False . None direct_call bool Controls if the function is called directly or not. Use this argument with caution. True **members Any A name -> value mapping of Enum members. {} Raises: Type Description ValueError The name is already used by another member. Returns: Type Description ET A newly created Enum type. Source code in enum_extensions/enums.py 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 def create ( self : ET , enum_name : str , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , direct_call : bool = True , ** members : Any , ) -> ET : \"\"\"Creates a new enumeration. Example: ```python Color = Enum(\"Color\", (\"RED\", \"GREEN\", \"BLUE\")) ``` Arguments: enum_name: The name of the new [`Enum`][enum_extensions.enums.Enum] to create. names: The names/values of the new enumeration members. module: The name of the module the [`Enum`][enum_extensions.enums.Enum] is created in. qualified_name: The actual location in the module where the enumeration can be found. type: A data type of the new [`Enum`][enum_extensions.enums.Enum]. start: The initial value of the new enumeration (used by [`auto`][enum_extensions.auto.auto]). unknown: Whether to enable unknown values of enumeration members. [`None`][None] means that it should be deduced from inheritance. The default value in the end is [`False`][False]. direct_call: Controls if the function is called directly or not. Use this argument with caution. **members: A `name -> value` mapping of [`Enum`][enum_extensions.enums.Enum] members. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] type. \"\"\" meta = standard_type ( self ) bases = ( self ,) if type is None else ( type , self ) enum_type = find_enum_type ( bases ) namespace = meta . __prepare__ ( enum_name , bases , start = start , unknown = unknown ) if names is not None : # special processing needed for strings if is_string ( names ): names = names . replace ( COMMA , SPACE ) . strip () . split () if is_mapping ( names ): namespace . update ( names ) else : iterator = iter ( names ) item = next ( iterator , null ) if is_not_null ( item ): iterator = prepend ( item , iterator ) if is_string ( item ): original_names , names = names , [] values = [] for count , name in enumerate ( original_names ): value = enum_type . enum_generate_next_value ( name , start , count , values . copy () ) values . append ( value ) names . append (( name , value )) iterator = iter ( names ) namespace . update ( iterator ) namespace . update ( members ) # TODO: replace the frame hack if a blessed way to know the calling # module is ever developed if module is None : try : module = get_frame ( DIRECT_CALLER if direct_call else NESTED_CALLER ) . f_globals [ NAME ] except ( AttributeError , ValueError , KeyError ): # pragma: no cover pass if module is None : # pragma: no cover make_namespace_unpicklable ( namespace ) else : namespace [ MODULE ] = module if qualified_name is None : if module is not None : qualified_name = QUALIFIED_NAME_STRING . format ( module , enum_name ) if qualified_name is not None : namespace [ QUALIFIED_NAME ] = qualified_name return meta . __new__ ( meta , enum_name , bases , namespace , unknown = unknown ) is_empty () Checks whether the enumeration does not contain any members. Example class Test ( Enum ): TEST = 42 assert Enum . is_empty () assert not Test . is_empty () Source code in enum_extensions/enums.py 877 878 879 880 881 882 883 884 885 886 887 888 889 def is_empty ( self ) -> bool : \"\"\"Checks whether the enumeration does not contain any members. Example: ```python class Test(Enum): TEST = 42 assert Enum.is_empty() assert not Test.is_empty() ``` \"\"\" return not self . _member_values add_member ( name , value ) Adds a new member to the enumeration. Example class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 black = Color . add_member ( \"BLACK\" , 0 ) # <Color.BLACK: 0> Parameters: Name Type Description Default name Optional [ str ] The name of a member. required value Any The value of a member. required Raises: Type Description ValueError The name is already used by another member. Returns: Type Description E A newly created Enum member. Source code in enum_extensions/enums.py 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 def add_member ( self : Type [ E ], name : Optional [ str ], value : Any ) -> E : \"\"\"Adds a new member to the enumeration. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 black = Color.add_member(\"BLACK\", 0) # <Color.BLACK: 0> ``` Arguments: name: The name of a member. value: The value of a member. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] member. \"\"\" if is_auto ( value ): if is_null ( value . value ): value . value = self . enum_generate_next_value ( name , self . _start , len ( self . _member_names ), self . _member_values . copy () ) value = value . value return create_enum_member ( name , value , self . _data_type , self , self . _new_function , self . _new_use_args , self . _dynamic_attributes , self . _flag , ) update ( ** name_to_value ) Updates the enumeration, adding members to it. Example class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Color . update ( BLACK = 0 , WHITE = 4 ) colors = ( Color . BLACK , Color . WHITE ) # (<Color.BLACK: 0>, <Color.WHITE: 4>) Parameters: Name Type Description Default **name_to_value Any Keywords argument in name -> value form. {} Raises: Type Description ValueError The name in name_to_value is already used by another member. Source code in enum_extensions/enums.py 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 def update ( self : Type [ E ], ** name_to_value : Any ) -> None : \"\"\"Updates the enumeration, adding members to it. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 Color.update(BLACK=0, WHITE=4) colors = (Color.BLACK, Color.WHITE) # (<Color.BLACK: 0>, <Color.WHITE: 4>) ``` Arguments: **name_to_value: Keywords argument in `name -> value` form. Raises: ValueError: The name in `name_to_value` is already used by another member. \"\"\" for name , value in name_to_value . items (): self . add_member ( name , value ) __contains__ ( data ) Checks whether the data is in Enum . data is contained in enumeration if: data is a member of said enumeration, or data is the value of one of the members. Example class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 assert Color . RED in Color assert 3 in Color assert 0 not in Color Parameters: Name Type Description Default data Any The data to check. required Returns: Type Description bool Whether the data is contained in Enum . Source code in enum_extensions/enums.py 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 def __contains__ ( self : Type [ E ], data : Any ) -> bool : \"\"\"Checks whether the `data` is in [`Enum`][enum_extensions.enums.Enum]. `data` is contained in enumeration if: - `data` is a member of said enumeration, or - `data` is the value of one of the members. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 assert Color.RED in Color assert 3 in Color assert 0 not in Color ``` Arguments: data: The data to check. Returns: Whether the `data` is contained in [`Enum`][enum_extensions.enums.Enum]. \"\"\" if is_instance ( data , self ): return True try : return data in self . _value_mapping except TypeError : return data in self . _member_values __getattr__ ( name ) Returns the Enum member matching name . Example >>> Color . BLUE < Color . BLUE : 3 > Parameters: Name Type Description Default name str The name of the member to find. required Raises: Type Description AttributeError The member was not found. Returns: Type Description E The member found. Source code in enum_extensions/enums.py 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 def __getattr__ ( self : Type [ E ], name : str ) -> E : \"\"\"Returns the [`Enum`][enum_extensions.enums.Enum] member matching `name`. Example: ```python >>> Color.BLUE <Color.BLUE: 3> ``` Arguments: name: The name of the member to find. Raises: AttributeError: The member was not found. Returns: The member found. \"\"\" if is_double_under_name ( name ): raise AttributeError ( name ) try : return self . _member_mapping [ name ] except KeyError : raise AttributeError ( name ) from None __getitem__ ( name ) Returns the Enum member matching name . Example >>> Color [ \"GREEN\" ] < Color . GREEN : 2 > Parameters: Name Type Description Default name str The name of the member to find. required Raises: Type Description KeyError The member was not found. Returns: Type Description E The member found. Source code in enum_extensions/enums.py 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 def __getitem__ ( self : Type [ E ], name : str ) -> E : \"\"\"Returns the [`Enum`][enum_extensions.enums.Enum] member matching `name`. Example: ```python >>> Color[\"GREEN\"] <Color.GREEN: 2> ``` Arguments: name: The name of the member to find. Raises: KeyError: The member was not found. Returns: The member found. \"\"\" return self . _member_mapping [ name ] __iter__ () Returns an iterator over unique Enum members in definition order. Example >>> tuple ( Color ) ( < Color . RED : 1 > , < Color . GREEN : 2 > , < Color . BLUE : 3 > ) Returns: Type Description Iterator [ E ] An iterator of unique Enum members. Source code in enum_extensions/enums.py 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def __iter__ ( self : Type [ E ]) -> Iterator [ E ]: \"\"\"Returns an iterator over unique [`Enum`][enum_extensions.enums.Enum] members in definition order. Example: ```python >>> tuple(Color) (<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>) ``` Returns: An iterator of unique [`Enum`][enum_extensions.enums.Enum] members. \"\"\" return self . iter_members () __reversed__ () Returns an iterator over unique Enum members in reverse definition order. Example >>> tuple ( reversed ( Color )) ( < Color . BLUE : 3 > , < Color . GREEN : 2 > , < Color . RED : 1 > ) Returns: Type Description Iterator [ E ] An iterator of unique Enum members. Source code in enum_extensions/enums.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 def __reversed__ ( self : Type [ E ]) -> Iterator [ E ]: \"\"\"Returns an iterator over unique [`Enum`][enum_extensions.enums.Enum] members in reverse definition order. Example: ```python >>> tuple(reversed(Color)) (<Color.BLUE: 3>, <Color.GREEN: 2>, <Color.RED: 1>) ``` Returns: An iterator of unique [`Enum`][enum_extensions.enums.Enum] members. \"\"\" return self . iter_members ( reverse = True ) __len__ () Returns the number of unique members (excluding aliases). Example >>> len ( Color ) 3 Returns: Type Description int The count of unique enumeration members. Source code in enum_extensions/enums.py 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 def __len__ ( self ) -> int : \"\"\"Returns the number of unique members (excluding aliases). Example: ```python >>> len(Color) 3 ``` Returns: The count of unique enumeration members. \"\"\" return len ( self . _member_names ) __repr__ () Returns the string used by repr calls. By default contains the Enum name. Example >>> Color < enum ` Color ` > Returns: Type Description str The string used in the repr function. Source code in enum_extensions/enums.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name. Example: ```python >>> Color <enum `Color`> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return ENUM_REPRESENTATION . format ( tick ( get_name ( self ))) iter_members ( reverse = False ) Returns an iterator over unique enumeration members in definition order, optionally reversing it. Example >>> list ( Color . iter_members ()) [ < Color . RED : 1 > , < Color . GREEN : 2 > , < Color . BLUE : 3 > ] >>> list ( Color . iter_members ( reverse = True )) [ < Color . BLUE : 3 > , < Color . GREEN : 2 > , < Color . RED : 1 > ] Parameters: Name Type Description Default reverse bool Whether to reverse the definition order. False Returns: Type Description Iterator [ E ] An iterator over unique members. Source code in enum_extensions/enums.py 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 def iter_members ( self : Type [ E ], reverse : bool = False ) -> Iterator [ E ]: \"\"\"Returns an iterator over unique enumeration members in definition order, optionally reversing it. Example: ```python >>> list(Color.iter_members()) [<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>] >>> list(Color.iter_members(reverse=True)) [<Color.BLUE: 3>, <Color.GREEN: 2>, <Color.RED: 1>] ``` Arguments: reverse: Whether to reverse the definition order. Returns: An iterator over unique members. \"\"\" names = self . _member_names if reverse : names = reversed ( names ) member_mapping = self . _member_mapping return ( member_mapping [ name ] for name in names ) members () property An immutable mapping of enumeration members (including aliases). Example >>> for name , member in self . members . items (): ... print ( name , member ) RED Color . RED GREEN Color . GREEN BLUE Color . BLUE Returns: Type Description StringMapping [ E ] An immutable mapping of all enumeration members. Source code in enum_extensions/enums.py 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 @property def members ( self : Type [ E ]) -> StringMapping [ E ]: \"\"\"An immutable mapping of enumeration members (including aliases). Example: ```python >>> for name, member in self.members.items(): ... print(name, member) RED Color.RED GREEN Color.GREEN BLUE Color.BLUE ``` Returns: An immutable mapping of all enumeration members. \"\"\" return MappingProxy ( self . _member_mapping ) from_name ( name ) Finds a member by name case insensitively . Example class Test ( Enum ): TEST = 13 test = Test . from_name ( \"test\" ) # <Test.TEST: 13> Parameters: Name Type Description Default name str The name to look up. required Raises: Type Description KeyError Member is not found. Returns: Type Description E The Enum member found. Source code in enum_extensions/enums.py 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 def from_name ( self : Type [ E ], name : str ) -> E : \"\"\"Finds a member by name *case insensitively*. Example: ```python class Test(Enum): TEST = 13 test = Test.from_name(\"test\") # <Test.TEST: 13> ``` Arguments: name: The name to look up. Raises: KeyError: Member is not found. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" return self . case_fold_names [ case_fold_name ( name )] from_value ( value , default = null ) Finds a member by value with an optional default value fallback. Example class Test ( Enum ): TEST = 25 test = Test . from_value ( 25 ) # <Test.TEST: 25> Parameters: Name Type Description Default value Any The value to look up. required default Nullable [ Any ] The default value to fall back to. null Raises: Type Description ValueError Member is not found and default is not provided. Returns: Type Description E The Enum member found. Source code in enum_extensions/enums.py 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 def from_value ( self : Type [ E ], value : Any , default : Nullable [ Any ] = null ) -> E : \"\"\"Finds a member by value with an optional `default` value fallback. Example: ```python class Test(Enum): TEST = 25 test = Test.from_value(25) # <Test.TEST: 25> ``` Arguments: value: The value to look up. default: The default value to fall back to. Raises: ValueError: Member is not found and `default` is not provided. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" try : return self ( value ) except ValueError : if is_null ( default ): raise return self ( default ) from_data ( data , default = null ) Finds a member by name or by value with an optional default value fallback. Example class Test ( Enum ): TEST = 42 test = Test . from_data ( \"test\" ) # <Test.TEST: 42> test = Test . from_data ( 42 ) # <Test.TEST: 42> Parameters: Name Type Description Default data Any The name or value to look up. required default Nullable [ Any ] The default value to fall back to. null Raises: Type Description ValueError Member is not found and default is not provided. Returns: Type Description E The Enum member found. Source code in enum_extensions/enums.py 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 def from_data ( self : Type [ E ], data : Any , default : Nullable [ Any ] = null ) -> E : \"\"\"Finds a member by name or by value with an optional `default` value fallback. Example: ```python class Test(Enum): TEST = 42 test = Test.from_data(\"test\") # <Test.TEST: 42> test = Test.from_data(42) # <Test.TEST: 42> ``` Arguments: data: The name or value to look up. default: The default value to fall back to. Raises: ValueError: Member is not found and `default` is not provided. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" if is_string ( data ): try : return self . from_name ( data ) except KeyError : pass try : return self . from_value ( data ) except ValueError : if is_null ( default ): raise return self . from_data ( default ) Enum A collection of name -> value pairs. Example enumeration: class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Accessing members via attributes: >>> Color . RED < Color . RED : 1 > Getting members by name: >>> Color [ \"GREEN\" ] < Color . GREEN : 2 > Alternatively, using values: >>> Color ( 3 ) < Color . BLUE : 3 > Enumerations can be iterated over, and know how many members they have: >>> len ( Color ) 3 >>> list ( Color ) [ < Color . RED : 1 > , < Color . GREEN : 2 > , < Color . BLUE : 3 > ] Methods can be added to enumerations, and members can have their own attributes; see the documentation for details. Source code in enum_extensions/enums.py 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 class Enum ( metaclass = EnumType ): \"\"\"A collection of `name -> value` pairs. Example enumeration: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 ``` Accessing members via attributes: ```python >>> Color.RED <Color.RED: 1> ``` Getting members by name: ```python >>> Color[\"GREEN\"] <Color.GREEN: 2> ``` Alternatively, using values: ```python >>> Color(3) <Color.BLUE: 3> ``` Enumerations can be iterated over, and know how many members they have: ```python >>> len(Color) 3 >>> list(Color) [<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>] ``` Methods can be added to enumerations, and members can have their own attributes; see the documentation for details. \"\"\" __enum_name__ : Optional [ str ] __enum_value__ : Any _sort_order : int def __new__ ( cls : Type [ EnumT ], value : Any ) -> EnumT : \"\"\"Looks up the member by value. Example: ```python >>> Color(1) <Color.RED: 1> ``` Arguments: value: The value to search for. Raises: ValueError: The member was not found. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" # all enum members are created during type construction without calling this method if type ( value ) is cls : return value try : return cls . _value_mapping [ value ] except KeyError : # not found, no need to do O(n) search pass except TypeError : # not hashable, then do long search, O(n) behavior for member in cls . _member_mapping . values (): if member . __enum_value__ == value : return member error = None # still not found -> try enum_missing hook try : result = cls . enum_missing ( value ) # type: ignore except AttributeError : # pragma: no cover result = None except Exception as error_happened : error = error_happened result = None if is_instance ( result , cls ): return result else : error_invalid = ValueError ( INVALID_VALUE . format ( repr ( value ), tick ( get_name ( cls )))) if result is None and error is None : # no result, no error raise error_invalid if error is None : error = ValueError ( ENUM_MISSING_ERROR . format ( get_name ( cls ), repr ( result ))) raise error_invalid from error def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name along with member name and value. Example: ```python >>> Color.BLUE <Color.BLUE: 3> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return ENUM_MEMBER_REPRESENTATION . format ( get_name ( type ( self )), self . __enum_checked_name__ , self . __enum_value__ ) def __str__ ( self ) -> str : \"\"\"Returns the string used by [`str`][str] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name along with member name. Example: ```python >>> print(Color.BLUE) Color.BLUE ``` Returns: The string used in the [`str`][str] function. \"\"\" return ENUM_MEMBER_STRING . format ( get_name ( type ( self )), self . __enum_checked_name__ ) def __format__ ( self , specification : str ) -> str : \"\"\"Returns the string used by [`format`][format] calls and f-strings. By default this function gives the same result as [`str`][str] does. Example: ```python >>> color = Color.RED >>> print(f\"{color}\") Color.RED ``` Returns: The string used in the [`format`][format] function and f-strings. \"\"\" data_type = self . _data_type if data_type is object : type , value = str , str ( self ) else : type , value = data_type , self . __enum_value__ return type . __format__ ( value , specification ) def __hash__ ( self ) -> int : return hash ( self . __enum_name__ ) def __reduce_ex__ ( self : EnumT , protocol : Any ) -> Tuple [ Type [ EnumT ], Tuple [ Any ]]: return type ( self ), ( self . __enum_value__ ,) @dynamic_attribute def __enum_checked_name__ ( self ) -> str : name = self . __enum_name__ return UNKNOWN if name is None else name @dynamic_attribute def name ( self ) -> str : \"\"\"The name of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return self . __enum_checked_name__ @dynamic_attribute def value ( self ) -> Any : \"\"\"The value of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return self . __enum_value__ @dynamic_attribute def title_name ( self ) -> str : \"\"\"The human-readable name of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return create_title ( self . __enum_checked_name__ ) enum_generate_next_value = staticmethod ( incremental_next_value ) __new__ ( value ) Looks up the member by value. Example >>> Color ( 1 ) < Color . RED : 1 > Parameters: Name Type Description Default value Any The value to search for. required Raises: Type Description ValueError The member was not found. Returns: Type Description EnumT The Enum member found. Source code in enum_extensions/enums.py 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 def __new__ ( cls : Type [ EnumT ], value : Any ) -> EnumT : \"\"\"Looks up the member by value. Example: ```python >>> Color(1) <Color.RED: 1> ``` Arguments: value: The value to search for. Raises: ValueError: The member was not found. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" # all enum members are created during type construction without calling this method if type ( value ) is cls : return value try : return cls . _value_mapping [ value ] except KeyError : # not found, no need to do O(n) search pass except TypeError : # not hashable, then do long search, O(n) behavior for member in cls . _member_mapping . values (): if member . __enum_value__ == value : return member error = None # still not found -> try enum_missing hook try : result = cls . enum_missing ( value ) # type: ignore except AttributeError : # pragma: no cover result = None except Exception as error_happened : error = error_happened result = None if is_instance ( result , cls ): return result else : error_invalid = ValueError ( INVALID_VALUE . format ( repr ( value ), tick ( get_name ( cls )))) if result is None and error is None : # no result, no error raise error_invalid if error is None : error = ValueError ( ENUM_MISSING_ERROR . format ( get_name ( cls ), repr ( result ))) raise error_invalid from error __repr__ () Returns the string used by repr calls. By default contains the Enum name along with member name and value. Example >>> Color . BLUE < Color . BLUE : 3 > Returns: Type Description str The string used in the repr function. Source code in enum_extensions/enums.py 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name along with member name and value. Example: ```python >>> Color.BLUE <Color.BLUE: 3> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return ENUM_MEMBER_REPRESENTATION . format ( get_name ( type ( self )), self . __enum_checked_name__ , self . __enum_value__ ) __str__ () Returns the string used by str calls. By default contains the Enum name along with member name. Example >>> print ( Color . BLUE ) Color . BLUE Returns: Type Description str The string used in the str function. Source code in enum_extensions/enums.py 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 def __str__ ( self ) -> str : \"\"\"Returns the string used by [`str`][str] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name along with member name. Example: ```python >>> print(Color.BLUE) Color.BLUE ``` Returns: The string used in the [`str`][str] function. \"\"\" return ENUM_MEMBER_STRING . format ( get_name ( type ( self )), self . __enum_checked_name__ ) __format__ ( specification ) Returns the string used by format calls and f-strings. By default this function gives the same result as str does. Example >>> color = Color . RED >>> print ( f \" { color } \" ) Color . RED Returns: Type Description str The string used in the format function and f-strings. Source code in enum_extensions/enums.py 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 def __format__ ( self , specification : str ) -> str : \"\"\"Returns the string used by [`format`][format] calls and f-strings. By default this function gives the same result as [`str`][str] does. Example: ```python >>> color = Color.RED >>> print(f\"{color}\") Color.RED ``` Returns: The string used in the [`format`][format] function and f-strings. \"\"\" data_type = self . _data_type if data_type is object : type , value = str , str ( self ) else : type , value = data_type , self . __enum_value__ return type . __format__ ( value , specification ) name () The name of the Enum member. Source code in enum_extensions/enums.py 1472 1473 1474 1475 @dynamic_attribute def name ( self ) -> str : \"\"\"The name of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return self . __enum_checked_name__ value () The value of the Enum member. Source code in enum_extensions/enums.py 1477 1478 1479 1480 @dynamic_attribute def value ( self ) -> Any : \"\"\"The value of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return self . __enum_value__ title_name () The human-readable name of the Enum member. Source code in enum_extensions/enums.py 1482 1483 1484 1485 @dynamic_attribute def title_name ( self ) -> str : \"\"\"The human-readable name of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return create_title ( self . __enum_checked_name__ ) IntEnum Bases: int , Enum An enumeration whose values are (and must be) integers. Source code in enum_extensions/enums.py 1507 1508 class IntEnum ( int , Enum ): \"\"\"An enumeration whose values are (and must be) integers.\"\"\" StringEnum Bases: str , Enum An enumeration whose values are (and must be) strings. Source code in enum_extensions/enums.py 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 class StringEnum ( str , Enum ): \"\"\"An enumeration whose values are (and must be) strings.\"\"\" @overload def __new__ ( cls : Type [ S ], item : buffer , encoding : str = ... , errors : str = ... ) -> S : ... @overload def __new__ ( cls : Type [ S ], item : Any ) -> S : ... def __new__ ( cls : Type [ S ], item : Any , encoding : str = UTF_8 , errors : str = STRICT ) -> S : if is_string ( item ): value = item else : # pragma: no cover value = str ( item , encoding , errors ) member = str . __new__ ( cls , value ) member . __enum_value__ = value return member enum_generate_next_value = staticmethod ( case_fold_name_next_value ) enum_generate_next_value ( name , start , count , values ) Generates an appropriate next value to use. Parameters: Name Type Description Default name Optional [ str ] The name of the Enum member which needs a value. required start Optional [ T ] An initial value to use. required count int The amount of already existing unique enumeration members. required values Sequence [ T ] All previously defined members. required Returns: Type Description T The generated value. Source code in enum_extensions/enums.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def enum_generate_next_value ( name : Optional [ str ], start : Optional [ T ], count : int , values : Sequence [ T ] ) -> T : \"\"\"Generates an appropriate next value to use. Arguments: name: The name of the [`Enum`][enum_extensions.enums.Enum] member which needs a value. start: An initial value to use. count: The amount of already existing unique enumeration members. values: All previously defined members. Returns: The generated value. \"\"\" raise NotImplementedError","title":"Enums"},{"location":"reference/enums/#enum_extensions.enums.EnumDict","text":"Bases: Namespace Tracks enumeration members and ensures their names are not reused. Source code in enum_extensions/enums.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 class EnumDict ( Namespace ): \"\"\"Tracks enumeration members and ensures their names are not reused.\"\"\" def __init__ ( self ) -> None : self . _generate_next_value : Optional [ GenerateNextValue [ Any ]] = None self . _start : Optional [ Any ] = None self . _ignore : Set [ str ] = set () self . _member_names : List [ str ] = [] self . _member_values : List [ Any ] = [] self . _mapping : StringDict [ Any ] = {} super () . __init__ () @property def generate_next_value ( self ) -> Optional [ GenerateNextValue [ Any ]]: return self . _generate_next_value @property def start ( self ) -> Optional [ Any ]: return self . _start @property def ignore ( self ) -> Set [ str ]: return self . _ignore def _set_generate_next_value ( self , generate_next_value : Optional [ GenerateNextValue [ Any ]] ) -> None : self . _generate_next_value = generate_next_value def _set_start ( self , start : Optional [ Any ]) -> None : self . _start = start def _set_ignore ( self , ignore : MaybeIterable [ str ]) -> None : if is_string ( ignore ): self . _ignore = set ( ignore . replace ( COMMA , SPACE ) . strip () . split ()) else : self . _ignore = set ( ignore ) @property def member_names ( self ) -> List [ str ]: return self . _member_names @property def member_values ( self ) -> List [ Any ]: return self . _member_values @property def mapping ( self ) -> StringDict [ Any ]: return self . _mapping def is_used ( self , name : str ) -> bool : return name in self def is_ignored ( self , name : str ) -> bool : return name in self . ignore def is_reserved ( self , name : str ) -> bool : return name in self . mapping def add_member ( self , name : str , value : MaybeAuto [ Any ]) -> None : if is_auto ( value ): if is_null ( value . value ): generate_next_value = self . generate_next_value if generate_next_value is None : raise RuntimeError ( CAN_NOT_USE_AUTO ) value . value = generate_next_value ( name , self . start , len ( self . member_names ), self . member_values . copy () ) value = value . value self . mapping [ name ] = value self . member_names . append ( name ) self . member_values . append ( value ) def __setitem__ ( self , name : str , value : Any ) -> None : if name == ENUM_GENERATE_NEXT_VALUE : self . _set_generate_next_value ( value ) elif name == ENUM_IGNORE : self . _set_ignore ( value ) elif name == ENUM_START : self . _set_start ( value ) elif self . is_reserved ( name ): raise ValueError ( ATTEMPT_TO_REUSE . format ( tick ( name ))) elif is_member ( value ): value = value . value self . add_member ( name , value ) elif is_non_member ( value ): value = value . value elif self . is_ignored ( name ) or is_double_under_name ( name ) or is_descriptor ( value ): pass elif self . is_used ( name ): raise ValueError ( ALREADY_DEFINED . format ( tick ( name ))) else : self . add_member ( name , value ) super () . __setitem__ ( name , value ) def update ( self , item : Union [ StringMapping [ Any ], StringPairs [ Any ]] = (), ** items : Any ) -> None : if is_mapping ( item ): for name , value in item . items (): self [ name ] = value else : for name , value in item : self [ name ] = value for name , value in items . items (): self [ name ] = value","title":"EnumDict"},{"location":"reference/enums/#enum_extensions.enums.EnumType","text":"Bases: type Metaclass for Enum . EnumType is responsible for setting the correct methods on the final enumeration , as well as creating its members , properly handling duplicates, providing iteration over the enumeration members, etc. Source code in enum_extensions/enums.py 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 class EnumType ( type ): \"\"\"Metaclass for [`Enum`][enum_extensions.enums.Enum]. [`EnumType`][enum_extensions.enums.EnumType] is responsible for setting the correct methods on the final *enumeration*, as well as creating its *members*, properly handling duplicates, providing iteration over the enumeration members, etc. \"\"\" _unknown : bool _flag : bool _start : Optional [ Any ] _member_names : List [ str ] _member_values : List [ Any ] _data_type : AnyType _new_function : DynamicCallable [ Any ] _new_use_args : bool _member_mapping : StringDict [ Enum ] _value_mapping : Dict [ Any , Enum ] _dynamic_attributes : Set [ str ] @classmethod def __prepare__ ( cls , name : str , bases : DynamicTuple [ AnyType ], * , ignore : Optional [ MaybeIterable [ str ]] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , flag : bool = False , ** kwargs : Any , ) -> EnumDict : namespace = EnumDict () enum_type = find_enum_type ( bases ) if ignore is None : ignore = () namespace . update ( enum_generate_next_value = get_attribute ( enum_type , ENUM_GENERATE_NEXT_VALUE , None ), enum_ignore = ignore , enum_start = start , ) return namespace def __new__ ( cls : Type [ ET ], enum_name : str , bases : DynamicTuple [ AnyType ], namespace : EnumDict , * , ignore : Optional [ MaybeIterable [ str ]] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , flag : bool = False , ** kwargs : Any , ) -> ET : global ENUM_DEFINED # add `enum_ignore` to itself enum_ignore = namespace . ignore enum_ignore . add ( ENUM_IGNORE ) # remove all names in `enum_ignore` for name in enum_ignore : if name in namespace : del namespace [ name ] enum_type = find_enum_type ( bases ) # type: ignore if enum_type is None and ENUM_DEFINED : # pragma: no cover enum_type = Enum data_type = find_data_type ( bases ) new = find_new ( namespace , data_type , enum_type ) enum_members = namespace . mapping . copy () # remove enum members so they do not get into new enum type for name in namespace . member_names : if name in namespace : del namespace [ name ] # check for invalid names invalid_names = set ( enum_members ) & INVALID_NAMES if invalid_names : names = concat_comma_space ( map ( tick , invalid_names )) raise ValueError ( INVALID_MEMBER_NAMES . format ( names )) namespace . setdefault ( DOCUMENTATION , ENUM_DOCUMENTATION ) # handle reduce if REDUCE not in namespace : if data_type is not object : pickle_methods = set ( vars ( data_type )) & PICKLE_METHODS if not pickle_methods : make_namespace_unpicklable ( namespace ) # create dummy enum type dummy_enum_type = super () . __new__ ( cls , enum_name , bases , EnumDict ()) # manipulate Method Resolution Order (MRO) mro = list ( dummy_enum_type . mro ()) try : mro . remove ( dummy_enum_type ) except ValueError : # pragma: no cover pass try : if mro . index ( data_type ) < mro . index ( enum_type ): # we need to preserve enum_type functions mro . remove ( enum_type ) mro . insert ( mro . index ( data_type ), enum_type ) except ValueError : # pragma: no cover pass bases = tuple ( mro ) # now back to tuple # create new enum type new_enum_type = super () . __new__ ( cls , enum_name , bases , namespace ) # on top of it, preserve names that should ideally belong to enums for name in ENUM_PRESERVE : if name in namespace : continue type_method = get_attribute ( new_enum_type , name ) data_method = get_attribute ( data_type , name , None ) enum_method = get_attribute ( enum_type , name , None ) if data_method is not None and data_method is type_method : set_attribute ( new_enum_type , name , enum_method ) # add information new_enum_type . _flag = flag new_enum_type . _start = namespace . start new_enum_type . _member_names = [] new_enum_type . _member_values = [] new_enum_type . _data_type = data_type new_enum_type . _new_function = new . function new_enum_type . _new_use_args = new . use_args # add mappings new_enum_type . _member_mapping = {} # name -> member new_enum_type . _value_mapping = {} # value -> member (if hashable) if unknown is None : unknown = get_attribute ( new_enum_type , UNKNOWN_PRIVATE , False ) new_enum_type . _unknown = unknown # save dynamic attributes to know if we an take the shortcut of # storing members in the type dict dynamic_attributes = { name for type in new_enum_type . mro () for name , value in vars ( type ) . items () if is_instance ( value , dynamic_attribute ) } new_enum_type . _dynamic_attributes = dynamic_attributes # create fellow enum members for name , value in enum_members . items (): create_enum_member ( name , value , data_type , new_enum_type , new . function , new . use_args , dynamic_attributes , flag , ) # save new if needed if ENUM_DEFINED : if new . save : new_enum_type . __new_member__ = new . function new_enum_type . __new__ = Enum . __new__ else : ENUM_DEFINED = True return new_enum_type @overload def __call__ ( self : Type [ E ], value : Any ) -> E : ... @overload def __call__ ( self : ET , value : str , names : Optional [ Names ] = ... , * , module : Optional [ str ] = ... , qualified_name : Optional [ str ] = ... , type : Optional [ AnyType ] = ... , start : Optional [ Any ] = ... , unknown : Optional [ bool ] = ... , ** members : Any , ) -> ET : ... def __call__ ( self : Type [ E ], value : Any , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , ** members : Any , ) -> Union [ E , Type [ E ]]: \"\"\"Looks up an existing member or creates a new enumeration. Example: Creation: ```python Color = Enum(\"Color\", RED=1, GREEN=2, BLUE=3) ``` Value lookup: ```python green = Color(2) # <Color.GREEN: 2> ``` Arguments: value: The value to search for or the name of the new [`Enum`][enum_extensions.enums.Enum] to create. names: The names/values of the new enumeration members. module: The name of the module the [`Enum`][enum_extensions.enums.Enum] is created in. qualified_name: The actual location in the module where the enumeration can be found. type: A data type of the new [`Enum`][enum_extensions.enums.Enum]. start: The initial value of the new enumeration (used by [`auto`][enum_extensions.auto.auto]). unknown: Whether to enable unknown values of enumeration members. [`None`][None] means that it should be inherited. The default value in the end is [`False`][False]. **members: A `name -> value` mapping of [`Enum`][enum_extensions.enums.Enum] members. Raises: ValueError: The member was not found. ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] type or a member found. \"\"\" if names or module or qualified_name or type or start or unknown or members : return self . create ( value , names , module = module , qualified_name = qualified_name , type = type , start = start , unknown = unknown , direct_call = False , ** members , ) return self . __new__ ( self , value ) def create ( self : ET , enum_name : str , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , direct_call : bool = True , ** members : Any , ) -> ET : \"\"\"Creates a new enumeration. Example: ```python Color = Enum(\"Color\", (\"RED\", \"GREEN\", \"BLUE\")) ``` Arguments: enum_name: The name of the new [`Enum`][enum_extensions.enums.Enum] to create. names: The names/values of the new enumeration members. module: The name of the module the [`Enum`][enum_extensions.enums.Enum] is created in. qualified_name: The actual location in the module where the enumeration can be found. type: A data type of the new [`Enum`][enum_extensions.enums.Enum]. start: The initial value of the new enumeration (used by [`auto`][enum_extensions.auto.auto]). unknown: Whether to enable unknown values of enumeration members. [`None`][None] means that it should be deduced from inheritance. The default value in the end is [`False`][False]. direct_call: Controls if the function is called directly or not. Use this argument with caution. **members: A `name -> value` mapping of [`Enum`][enum_extensions.enums.Enum] members. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] type. \"\"\" meta = standard_type ( self ) bases = ( self ,) if type is None else ( type , self ) enum_type = find_enum_type ( bases ) namespace = meta . __prepare__ ( enum_name , bases , start = start , unknown = unknown ) if names is not None : # special processing needed for strings if is_string ( names ): names = names . replace ( COMMA , SPACE ) . strip () . split () if is_mapping ( names ): namespace . update ( names ) else : iterator = iter ( names ) item = next ( iterator , null ) if is_not_null ( item ): iterator = prepend ( item , iterator ) if is_string ( item ): original_names , names = names , [] values = [] for count , name in enumerate ( original_names ): value = enum_type . enum_generate_next_value ( name , start , count , values . copy () ) values . append ( value ) names . append (( name , value )) iterator = iter ( names ) namespace . update ( iterator ) namespace . update ( members ) # TODO: replace the frame hack if a blessed way to know the calling # module is ever developed if module is None : try : module = get_frame ( DIRECT_CALLER if direct_call else NESTED_CALLER ) . f_globals [ NAME ] except ( AttributeError , ValueError , KeyError ): # pragma: no cover pass if module is None : # pragma: no cover make_namespace_unpicklable ( namespace ) else : namespace [ MODULE ] = module if qualified_name is None : if module is not None : qualified_name = QUALIFIED_NAME_STRING . format ( module , enum_name ) if qualified_name is not None : namespace [ QUALIFIED_NAME ] = qualified_name return meta . __new__ ( meta , enum_name , bases , namespace , unknown = unknown ) def is_empty ( self ) -> bool : \"\"\"Checks whether the enumeration does not contain any members. Example: ```python class Test(Enum): TEST = 42 assert Enum.is_empty() assert not Test.is_empty() ``` \"\"\" return not self . _member_values def add_member ( self : Type [ E ], name : Optional [ str ], value : Any ) -> E : \"\"\"Adds a new member to the enumeration. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 black = Color.add_member(\"BLACK\", 0) # <Color.BLACK: 0> ``` Arguments: name: The name of a member. value: The value of a member. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] member. \"\"\" if is_auto ( value ): if is_null ( value . value ): value . value = self . enum_generate_next_value ( name , self . _start , len ( self . _member_names ), self . _member_values . copy () ) value = value . value return create_enum_member ( name , value , self . _data_type , self , self . _new_function , self . _new_use_args , self . _dynamic_attributes , self . _flag , ) def update ( self : Type [ E ], ** name_to_value : Any ) -> None : \"\"\"Updates the enumeration, adding members to it. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 Color.update(BLACK=0, WHITE=4) colors = (Color.BLACK, Color.WHITE) # (<Color.BLACK: 0>, <Color.WHITE: 4>) ``` Arguments: **name_to_value: Keywords argument in `name -> value` form. Raises: ValueError: The name in `name_to_value` is already used by another member. \"\"\" for name , value in name_to_value . items (): self . add_member ( name , value ) def __bool__ ( self ) -> Literal [ True ]: return True def __contains__ ( self : Type [ E ], data : Any ) -> bool : \"\"\"Checks whether the `data` is in [`Enum`][enum_extensions.enums.Enum]. `data` is contained in enumeration if: - `data` is a member of said enumeration, or - `data` is the value of one of the members. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 assert Color.RED in Color assert 3 in Color assert 0 not in Color ``` Arguments: data: The data to check. Returns: Whether the `data` is contained in [`Enum`][enum_extensions.enums.Enum]. \"\"\" if is_instance ( data , self ): return True try : return data in self . _value_mapping except TypeError : return data in self . _member_values def __delattr__ ( self , name : str ) -> None : if name in self . _member_mapping : raise AttributeError ( CAN_NOT_DELETE_MEMBER . format ( tick ( name ))) super () . __delattr__ ( name ) def __getattr__ ( self : Type [ E ], name : str ) -> E : \"\"\"Returns the [`Enum`][enum_extensions.enums.Enum] member matching `name`. Example: ```python >>> Color.BLUE <Color.BLUE: 3> ``` Arguments: name: The name of the member to find. Raises: AttributeError: The member was not found. Returns: The member found. \"\"\" if is_double_under_name ( name ): raise AttributeError ( name ) try : return self . _member_mapping [ name ] except KeyError : raise AttributeError ( name ) from None def __getitem__ ( self : Type [ E ], name : str ) -> E : \"\"\"Returns the [`Enum`][enum_extensions.enums.Enum] member matching `name`. Example: ```python >>> Color[\"GREEN\"] <Color.GREEN: 2> ``` Arguments: name: The name of the member to find. Raises: KeyError: The member was not found. Returns: The member found. \"\"\" return self . _member_mapping [ name ] def __iter__ ( self : Type [ E ]) -> Iterator [ E ]: \"\"\"Returns an iterator over unique [`Enum`][enum_extensions.enums.Enum] members in definition order. Example: ```python >>> tuple(Color) (<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>) ``` Returns: An iterator of unique [`Enum`][enum_extensions.enums.Enum] members. \"\"\" return self . iter_members () def __reversed__ ( self : Type [ E ]) -> Iterator [ E ]: \"\"\"Returns an iterator over unique [`Enum`][enum_extensions.enums.Enum] members in reverse definition order. Example: ```python >>> tuple(reversed(Color)) (<Color.BLUE: 3>, <Color.GREEN: 2>, <Color.RED: 1>) ``` Returns: An iterator of unique [`Enum`][enum_extensions.enums.Enum] members. \"\"\" return self . iter_members ( reverse = True ) def __len__ ( self ) -> int : \"\"\"Returns the number of unique members (excluding aliases). Example: ```python >>> len(Color) 3 ``` Returns: The count of unique enumeration members. \"\"\" return len ( self . _member_names ) def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name. Example: ```python >>> Color <enum `Color`> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return ENUM_REPRESENTATION . format ( tick ( get_name ( self ))) def __setattr__ ( self , name : str , value : Any ) -> None : member_mapping = vars ( self ) . get ( MEMBER_MAPPING_PRIVATE , {}) # prevent recursion if name in member_mapping : raise AttributeError ( CAN_NOT_REASSIGN_MEMBER . format ( tick ( name ))) super () . __setattr__ ( name , value ) def iter_members ( self : Type [ E ], reverse : bool = False ) -> Iterator [ E ]: \"\"\"Returns an iterator over unique enumeration members in definition order, optionally reversing it. Example: ```python >>> list(Color.iter_members()) [<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>] >>> list(Color.iter_members(reverse=True)) [<Color.BLUE: 3>, <Color.GREEN: 2>, <Color.RED: 1>] ``` Arguments: reverse: Whether to reverse the definition order. Returns: An iterator over unique members. \"\"\" names = self . _member_names if reverse : names = reversed ( names ) member_mapping = self . _member_mapping return ( member_mapping [ name ] for name in names ) @property def members ( self : Type [ E ]) -> StringMapping [ E ]: \"\"\"An immutable mapping of enumeration members (including aliases). Example: ```python >>> for name, member in self.members.items(): ... print(name, member) RED Color.RED GREEN Color.GREEN BLUE Color.BLUE ``` Returns: An immutable mapping of all enumeration members. \"\"\" return MappingProxy ( self . _member_mapping ) __members__ = members @property def case_fold_names ( self : Type [ E ]) -> StringMapping [ E ]: return { case_fold_name ( name ): member for name , member in self . _member_mapping . items ()} def from_name ( self : Type [ E ], name : str ) -> E : \"\"\"Finds a member by name *case insensitively*. Example: ```python class Test(Enum): TEST = 13 test = Test.from_name(\"test\") # <Test.TEST: 13> ``` Arguments: name: The name to look up. Raises: KeyError: Member is not found. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" return self . case_fold_names [ case_fold_name ( name )] def from_value ( self : Type [ E ], value : Any , default : Nullable [ Any ] = null ) -> E : \"\"\"Finds a member by value with an optional `default` value fallback. Example: ```python class Test(Enum): TEST = 25 test = Test.from_value(25) # <Test.TEST: 25> ``` Arguments: value: The value to look up. default: The default value to fall back to. Raises: ValueError: Member is not found and `default` is not provided. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" try : return self ( value ) except ValueError : if is_null ( default ): raise return self ( default ) def from_data ( self : Type [ E ], data : Any , default : Nullable [ Any ] = null ) -> E : \"\"\"Finds a member by name or by value with an optional `default` value fallback. Example: ```python class Test(Enum): TEST = 42 test = Test.from_data(\"test\") # <Test.TEST: 42> test = Test.from_data(42) # <Test.TEST: 42> ``` Arguments: data: The name or value to look up. default: The default value to fall back to. Raises: ValueError: Member is not found and `default` is not provided. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" if is_string ( data ): try : return self . from_name ( data ) except KeyError : pass try : return self . from_value ( data ) except ValueError : if is_null ( default ): raise return self . from_data ( default ) def enum_missing ( self : Type [ E ], value : Any ) -> Optional [ E ]: if self . _unknown : return self . add_member ( None , value ) return None","title":"EnumType"},{"location":"reference/enums/#enum_extensions.enums.EnumType.__call__","text":"Looks up an existing member or creates a new enumeration. Example Creation: Color = Enum ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 3 ) Value lookup: green = Color ( 2 ) # <Color.GREEN: 2> Parameters: Name Type Description Default value Any The value to search for or the name of the new Enum to create. required names Optional [ Names ] The names/values of the new enumeration members. None module Optional [ str ] The name of the module the Enum is created in. None qualified_name Optional [ str ] The actual location in the module where the enumeration can be found. None type Optional [ AnyType ] A data type of the new Enum . None start Optional [ Any ] The initial value of the new enumeration (used by auto ). None unknown Optional [ bool ] Whether to enable unknown values of enumeration members. None means that it should be inherited. The default value in the end is False . None **members Any A name -> value mapping of Enum members. {} Raises: Type Description ValueError The member was not found. ValueError The name is already used by another member. Returns: Type Description Union [ E , Type [ E ]] A newly created Enum type or a member found. Source code in enum_extensions/enums.py 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 def __call__ ( self : Type [ E ], value : Any , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , ** members : Any , ) -> Union [ E , Type [ E ]]: \"\"\"Looks up an existing member or creates a new enumeration. Example: Creation: ```python Color = Enum(\"Color\", RED=1, GREEN=2, BLUE=3) ``` Value lookup: ```python green = Color(2) # <Color.GREEN: 2> ``` Arguments: value: The value to search for or the name of the new [`Enum`][enum_extensions.enums.Enum] to create. names: The names/values of the new enumeration members. module: The name of the module the [`Enum`][enum_extensions.enums.Enum] is created in. qualified_name: The actual location in the module where the enumeration can be found. type: A data type of the new [`Enum`][enum_extensions.enums.Enum]. start: The initial value of the new enumeration (used by [`auto`][enum_extensions.auto.auto]). unknown: Whether to enable unknown values of enumeration members. [`None`][None] means that it should be inherited. The default value in the end is [`False`][False]. **members: A `name -> value` mapping of [`Enum`][enum_extensions.enums.Enum] members. Raises: ValueError: The member was not found. ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] type or a member found. \"\"\" if names or module or qualified_name or type or start or unknown or members : return self . create ( value , names , module = module , qualified_name = qualified_name , type = type , start = start , unknown = unknown , direct_call = False , ** members , ) return self . __new__ ( self , value )","title":"__call__()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.create","text":"Creates a new enumeration. Example Color = Enum ( \"Color\" , ( \"RED\" , \"GREEN\" , \"BLUE\" )) Parameters: Name Type Description Default enum_name str The name of the new Enum to create. required names Optional [ Names ] The names/values of the new enumeration members. None module Optional [ str ] The name of the module the Enum is created in. None qualified_name Optional [ str ] The actual location in the module where the enumeration can be found. None type Optional [ AnyType ] A data type of the new Enum . None start Optional [ Any ] The initial value of the new enumeration (used by auto ). None unknown Optional [ bool ] Whether to enable unknown values of enumeration members. None means that it should be deduced from inheritance. The default value in the end is False . None direct_call bool Controls if the function is called directly or not. Use this argument with caution. True **members Any A name -> value mapping of Enum members. {} Raises: Type Description ValueError The name is already used by another member. Returns: Type Description ET A newly created Enum type. Source code in enum_extensions/enums.py 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 def create ( self : ET , enum_name : str , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , unknown : Optional [ bool ] = None , direct_call : bool = True , ** members : Any , ) -> ET : \"\"\"Creates a new enumeration. Example: ```python Color = Enum(\"Color\", (\"RED\", \"GREEN\", \"BLUE\")) ``` Arguments: enum_name: The name of the new [`Enum`][enum_extensions.enums.Enum] to create. names: The names/values of the new enumeration members. module: The name of the module the [`Enum`][enum_extensions.enums.Enum] is created in. qualified_name: The actual location in the module where the enumeration can be found. type: A data type of the new [`Enum`][enum_extensions.enums.Enum]. start: The initial value of the new enumeration (used by [`auto`][enum_extensions.auto.auto]). unknown: Whether to enable unknown values of enumeration members. [`None`][None] means that it should be deduced from inheritance. The default value in the end is [`False`][False]. direct_call: Controls if the function is called directly or not. Use this argument with caution. **members: A `name -> value` mapping of [`Enum`][enum_extensions.enums.Enum] members. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] type. \"\"\" meta = standard_type ( self ) bases = ( self ,) if type is None else ( type , self ) enum_type = find_enum_type ( bases ) namespace = meta . __prepare__ ( enum_name , bases , start = start , unknown = unknown ) if names is not None : # special processing needed for strings if is_string ( names ): names = names . replace ( COMMA , SPACE ) . strip () . split () if is_mapping ( names ): namespace . update ( names ) else : iterator = iter ( names ) item = next ( iterator , null ) if is_not_null ( item ): iterator = prepend ( item , iterator ) if is_string ( item ): original_names , names = names , [] values = [] for count , name in enumerate ( original_names ): value = enum_type . enum_generate_next_value ( name , start , count , values . copy () ) values . append ( value ) names . append (( name , value )) iterator = iter ( names ) namespace . update ( iterator ) namespace . update ( members ) # TODO: replace the frame hack if a blessed way to know the calling # module is ever developed if module is None : try : module = get_frame ( DIRECT_CALLER if direct_call else NESTED_CALLER ) . f_globals [ NAME ] except ( AttributeError , ValueError , KeyError ): # pragma: no cover pass if module is None : # pragma: no cover make_namespace_unpicklable ( namespace ) else : namespace [ MODULE ] = module if qualified_name is None : if module is not None : qualified_name = QUALIFIED_NAME_STRING . format ( module , enum_name ) if qualified_name is not None : namespace [ QUALIFIED_NAME ] = qualified_name return meta . __new__ ( meta , enum_name , bases , namespace , unknown = unknown )","title":"create()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.is_empty","text":"Checks whether the enumeration does not contain any members. Example class Test ( Enum ): TEST = 42 assert Enum . is_empty () assert not Test . is_empty () Source code in enum_extensions/enums.py 877 878 879 880 881 882 883 884 885 886 887 888 889 def is_empty ( self ) -> bool : \"\"\"Checks whether the enumeration does not contain any members. Example: ```python class Test(Enum): TEST = 42 assert Enum.is_empty() assert not Test.is_empty() ``` \"\"\" return not self . _member_values","title":"is_empty()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.add_member","text":"Adds a new member to the enumeration. Example class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 black = Color . add_member ( \"BLACK\" , 0 ) # <Color.BLACK: 0> Parameters: Name Type Description Default name Optional [ str ] The name of a member. required value Any The value of a member. required Raises: Type Description ValueError The name is already used by another member. Returns: Type Description E A newly created Enum member. Source code in enum_extensions/enums.py 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 def add_member ( self : Type [ E ], name : Optional [ str ], value : Any ) -> E : \"\"\"Adds a new member to the enumeration. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 black = Color.add_member(\"BLACK\", 0) # <Color.BLACK: 0> ``` Arguments: name: The name of a member. value: The value of a member. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Enum`][enum_extensions.enums.Enum] member. \"\"\" if is_auto ( value ): if is_null ( value . value ): value . value = self . enum_generate_next_value ( name , self . _start , len ( self . _member_names ), self . _member_values . copy () ) value = value . value return create_enum_member ( name , value , self . _data_type , self , self . _new_function , self . _new_use_args , self . _dynamic_attributes , self . _flag , )","title":"add_member()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.update","text":"Updates the enumeration, adding members to it. Example class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Color . update ( BLACK = 0 , WHITE = 4 ) colors = ( Color . BLACK , Color . WHITE ) # (<Color.BLACK: 0>, <Color.WHITE: 4>) Parameters: Name Type Description Default **name_to_value Any Keywords argument in name -> value form. {} Raises: Type Description ValueError The name in name_to_value is already used by another member. Source code in enum_extensions/enums.py 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 def update ( self : Type [ E ], ** name_to_value : Any ) -> None : \"\"\"Updates the enumeration, adding members to it. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 Color.update(BLACK=0, WHITE=4) colors = (Color.BLACK, Color.WHITE) # (<Color.BLACK: 0>, <Color.WHITE: 4>) ``` Arguments: **name_to_value: Keywords argument in `name -> value` form. Raises: ValueError: The name in `name_to_value` is already used by another member. \"\"\" for name , value in name_to_value . items (): self . add_member ( name , value )","title":"update()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.__contains__","text":"Checks whether the data is in Enum . data is contained in enumeration if: data is a member of said enumeration, or data is the value of one of the members. Example class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 assert Color . RED in Color assert 3 in Color assert 0 not in Color Parameters: Name Type Description Default data Any The data to check. required Returns: Type Description bool Whether the data is contained in Enum . Source code in enum_extensions/enums.py 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 def __contains__ ( self : Type [ E ], data : Any ) -> bool : \"\"\"Checks whether the `data` is in [`Enum`][enum_extensions.enums.Enum]. `data` is contained in enumeration if: - `data` is a member of said enumeration, or - `data` is the value of one of the members. Example: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 assert Color.RED in Color assert 3 in Color assert 0 not in Color ``` Arguments: data: The data to check. Returns: Whether the `data` is contained in [`Enum`][enum_extensions.enums.Enum]. \"\"\" if is_instance ( data , self ): return True try : return data in self . _value_mapping except TypeError : return data in self . _member_values","title":"__contains__()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.__getattr__","text":"Returns the Enum member matching name . Example >>> Color . BLUE < Color . BLUE : 3 > Parameters: Name Type Description Default name str The name of the member to find. required Raises: Type Description AttributeError The member was not found. Returns: Type Description E The member found. Source code in enum_extensions/enums.py 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 def __getattr__ ( self : Type [ E ], name : str ) -> E : \"\"\"Returns the [`Enum`][enum_extensions.enums.Enum] member matching `name`. Example: ```python >>> Color.BLUE <Color.BLUE: 3> ``` Arguments: name: The name of the member to find. Raises: AttributeError: The member was not found. Returns: The member found. \"\"\" if is_double_under_name ( name ): raise AttributeError ( name ) try : return self . _member_mapping [ name ] except KeyError : raise AttributeError ( name ) from None","title":"__getattr__()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.__getitem__","text":"Returns the Enum member matching name . Example >>> Color [ \"GREEN\" ] < Color . GREEN : 2 > Parameters: Name Type Description Default name str The name of the member to find. required Raises: Type Description KeyError The member was not found. Returns: Type Description E The member found. Source code in enum_extensions/enums.py 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 def __getitem__ ( self : Type [ E ], name : str ) -> E : \"\"\"Returns the [`Enum`][enum_extensions.enums.Enum] member matching `name`. Example: ```python >>> Color[\"GREEN\"] <Color.GREEN: 2> ``` Arguments: name: The name of the member to find. Raises: KeyError: The member was not found. Returns: The member found. \"\"\" return self . _member_mapping [ name ]","title":"__getitem__()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.__iter__","text":"Returns an iterator over unique Enum members in definition order. Example >>> tuple ( Color ) ( < Color . RED : 1 > , < Color . GREEN : 2 > , < Color . BLUE : 3 > ) Returns: Type Description Iterator [ E ] An iterator of unique Enum members. Source code in enum_extensions/enums.py 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def __iter__ ( self : Type [ E ]) -> Iterator [ E ]: \"\"\"Returns an iterator over unique [`Enum`][enum_extensions.enums.Enum] members in definition order. Example: ```python >>> tuple(Color) (<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>) ``` Returns: An iterator of unique [`Enum`][enum_extensions.enums.Enum] members. \"\"\" return self . iter_members ()","title":"__iter__()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.__reversed__","text":"Returns an iterator over unique Enum members in reverse definition order. Example >>> tuple ( reversed ( Color )) ( < Color . BLUE : 3 > , < Color . GREEN : 2 > , < Color . RED : 1 > ) Returns: Type Description Iterator [ E ] An iterator of unique Enum members. Source code in enum_extensions/enums.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 def __reversed__ ( self : Type [ E ]) -> Iterator [ E ]: \"\"\"Returns an iterator over unique [`Enum`][enum_extensions.enums.Enum] members in reverse definition order. Example: ```python >>> tuple(reversed(Color)) (<Color.BLUE: 3>, <Color.GREEN: 2>, <Color.RED: 1>) ``` Returns: An iterator of unique [`Enum`][enum_extensions.enums.Enum] members. \"\"\" return self . iter_members ( reverse = True )","title":"__reversed__()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.__len__","text":"Returns the number of unique members (excluding aliases). Example >>> len ( Color ) 3 Returns: Type Description int The count of unique enumeration members. Source code in enum_extensions/enums.py 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 def __len__ ( self ) -> int : \"\"\"Returns the number of unique members (excluding aliases). Example: ```python >>> len(Color) 3 ``` Returns: The count of unique enumeration members. \"\"\" return len ( self . _member_names )","title":"__len__()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.__repr__","text":"Returns the string used by repr calls. By default contains the Enum name. Example >>> Color < enum ` Color ` > Returns: Type Description str The string used in the repr function. Source code in enum_extensions/enums.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name. Example: ```python >>> Color <enum `Color`> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return ENUM_REPRESENTATION . format ( tick ( get_name ( self )))","title":"__repr__()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.iter_members","text":"Returns an iterator over unique enumeration members in definition order, optionally reversing it. Example >>> list ( Color . iter_members ()) [ < Color . RED : 1 > , < Color . GREEN : 2 > , < Color . BLUE : 3 > ] >>> list ( Color . iter_members ( reverse = True )) [ < Color . BLUE : 3 > , < Color . GREEN : 2 > , < Color . RED : 1 > ] Parameters: Name Type Description Default reverse bool Whether to reverse the definition order. False Returns: Type Description Iterator [ E ] An iterator over unique members. Source code in enum_extensions/enums.py 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 def iter_members ( self : Type [ E ], reverse : bool = False ) -> Iterator [ E ]: \"\"\"Returns an iterator over unique enumeration members in definition order, optionally reversing it. Example: ```python >>> list(Color.iter_members()) [<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>] >>> list(Color.iter_members(reverse=True)) [<Color.BLUE: 3>, <Color.GREEN: 2>, <Color.RED: 1>] ``` Arguments: reverse: Whether to reverse the definition order. Returns: An iterator over unique members. \"\"\" names = self . _member_names if reverse : names = reversed ( names ) member_mapping = self . _member_mapping return ( member_mapping [ name ] for name in names )","title":"iter_members()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.members","text":"An immutable mapping of enumeration members (including aliases). Example >>> for name , member in self . members . items (): ... print ( name , member ) RED Color . RED GREEN Color . GREEN BLUE Color . BLUE Returns: Type Description StringMapping [ E ] An immutable mapping of all enumeration members. Source code in enum_extensions/enums.py 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 @property def members ( self : Type [ E ]) -> StringMapping [ E ]: \"\"\"An immutable mapping of enumeration members (including aliases). Example: ```python >>> for name, member in self.members.items(): ... print(name, member) RED Color.RED GREEN Color.GREEN BLUE Color.BLUE ``` Returns: An immutable mapping of all enumeration members. \"\"\" return MappingProxy ( self . _member_mapping )","title":"members()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.from_name","text":"Finds a member by name case insensitively . Example class Test ( Enum ): TEST = 13 test = Test . from_name ( \"test\" ) # <Test.TEST: 13> Parameters: Name Type Description Default name str The name to look up. required Raises: Type Description KeyError Member is not found. Returns: Type Description E The Enum member found. Source code in enum_extensions/enums.py 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 def from_name ( self : Type [ E ], name : str ) -> E : \"\"\"Finds a member by name *case insensitively*. Example: ```python class Test(Enum): TEST = 13 test = Test.from_name(\"test\") # <Test.TEST: 13> ``` Arguments: name: The name to look up. Raises: KeyError: Member is not found. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" return self . case_fold_names [ case_fold_name ( name )]","title":"from_name()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.from_value","text":"Finds a member by value with an optional default value fallback. Example class Test ( Enum ): TEST = 25 test = Test . from_value ( 25 ) # <Test.TEST: 25> Parameters: Name Type Description Default value Any The value to look up. required default Nullable [ Any ] The default value to fall back to. null Raises: Type Description ValueError Member is not found and default is not provided. Returns: Type Description E The Enum member found. Source code in enum_extensions/enums.py 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 def from_value ( self : Type [ E ], value : Any , default : Nullable [ Any ] = null ) -> E : \"\"\"Finds a member by value with an optional `default` value fallback. Example: ```python class Test(Enum): TEST = 25 test = Test.from_value(25) # <Test.TEST: 25> ``` Arguments: value: The value to look up. default: The default value to fall back to. Raises: ValueError: Member is not found and `default` is not provided. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" try : return self ( value ) except ValueError : if is_null ( default ): raise return self ( default )","title":"from_value()"},{"location":"reference/enums/#enum_extensions.enums.EnumType.from_data","text":"Finds a member by name or by value with an optional default value fallback. Example class Test ( Enum ): TEST = 42 test = Test . from_data ( \"test\" ) # <Test.TEST: 42> test = Test . from_data ( 42 ) # <Test.TEST: 42> Parameters: Name Type Description Default data Any The name or value to look up. required default Nullable [ Any ] The default value to fall back to. null Raises: Type Description ValueError Member is not found and default is not provided. Returns: Type Description E The Enum member found. Source code in enum_extensions/enums.py 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 def from_data ( self : Type [ E ], data : Any , default : Nullable [ Any ] = null ) -> E : \"\"\"Finds a member by name or by value with an optional `default` value fallback. Example: ```python class Test(Enum): TEST = 42 test = Test.from_data(\"test\") # <Test.TEST: 42> test = Test.from_data(42) # <Test.TEST: 42> ``` Arguments: data: The name or value to look up. default: The default value to fall back to. Raises: ValueError: Member is not found and `default` is not provided. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" if is_string ( data ): try : return self . from_name ( data ) except KeyError : pass try : return self . from_value ( data ) except ValueError : if is_null ( default ): raise return self . from_data ( default )","title":"from_data()"},{"location":"reference/enums/#enum_extensions.enums.Enum","text":"A collection of name -> value pairs. Example enumeration: class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 Accessing members via attributes: >>> Color . RED < Color . RED : 1 > Getting members by name: >>> Color [ \"GREEN\" ] < Color . GREEN : 2 > Alternatively, using values: >>> Color ( 3 ) < Color . BLUE : 3 > Enumerations can be iterated over, and know how many members they have: >>> len ( Color ) 3 >>> list ( Color ) [ < Color . RED : 1 > , < Color . GREEN : 2 > , < Color . BLUE : 3 > ] Methods can be added to enumerations, and members can have their own attributes; see the documentation for details. Source code in enum_extensions/enums.py 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 class Enum ( metaclass = EnumType ): \"\"\"A collection of `name -> value` pairs. Example enumeration: ```python class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 ``` Accessing members via attributes: ```python >>> Color.RED <Color.RED: 1> ``` Getting members by name: ```python >>> Color[\"GREEN\"] <Color.GREEN: 2> ``` Alternatively, using values: ```python >>> Color(3) <Color.BLUE: 3> ``` Enumerations can be iterated over, and know how many members they have: ```python >>> len(Color) 3 >>> list(Color) [<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>] ``` Methods can be added to enumerations, and members can have their own attributes; see the documentation for details. \"\"\" __enum_name__ : Optional [ str ] __enum_value__ : Any _sort_order : int def __new__ ( cls : Type [ EnumT ], value : Any ) -> EnumT : \"\"\"Looks up the member by value. Example: ```python >>> Color(1) <Color.RED: 1> ``` Arguments: value: The value to search for. Raises: ValueError: The member was not found. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" # all enum members are created during type construction without calling this method if type ( value ) is cls : return value try : return cls . _value_mapping [ value ] except KeyError : # not found, no need to do O(n) search pass except TypeError : # not hashable, then do long search, O(n) behavior for member in cls . _member_mapping . values (): if member . __enum_value__ == value : return member error = None # still not found -> try enum_missing hook try : result = cls . enum_missing ( value ) # type: ignore except AttributeError : # pragma: no cover result = None except Exception as error_happened : error = error_happened result = None if is_instance ( result , cls ): return result else : error_invalid = ValueError ( INVALID_VALUE . format ( repr ( value ), tick ( get_name ( cls )))) if result is None and error is None : # no result, no error raise error_invalid if error is None : error = ValueError ( ENUM_MISSING_ERROR . format ( get_name ( cls ), repr ( result ))) raise error_invalid from error def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name along with member name and value. Example: ```python >>> Color.BLUE <Color.BLUE: 3> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return ENUM_MEMBER_REPRESENTATION . format ( get_name ( type ( self )), self . __enum_checked_name__ , self . __enum_value__ ) def __str__ ( self ) -> str : \"\"\"Returns the string used by [`str`][str] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name along with member name. Example: ```python >>> print(Color.BLUE) Color.BLUE ``` Returns: The string used in the [`str`][str] function. \"\"\" return ENUM_MEMBER_STRING . format ( get_name ( type ( self )), self . __enum_checked_name__ ) def __format__ ( self , specification : str ) -> str : \"\"\"Returns the string used by [`format`][format] calls and f-strings. By default this function gives the same result as [`str`][str] does. Example: ```python >>> color = Color.RED >>> print(f\"{color}\") Color.RED ``` Returns: The string used in the [`format`][format] function and f-strings. \"\"\" data_type = self . _data_type if data_type is object : type , value = str , str ( self ) else : type , value = data_type , self . __enum_value__ return type . __format__ ( value , specification ) def __hash__ ( self ) -> int : return hash ( self . __enum_name__ ) def __reduce_ex__ ( self : EnumT , protocol : Any ) -> Tuple [ Type [ EnumT ], Tuple [ Any ]]: return type ( self ), ( self . __enum_value__ ,) @dynamic_attribute def __enum_checked_name__ ( self ) -> str : name = self . __enum_name__ return UNKNOWN if name is None else name @dynamic_attribute def name ( self ) -> str : \"\"\"The name of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return self . __enum_checked_name__ @dynamic_attribute def value ( self ) -> Any : \"\"\"The value of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return self . __enum_value__ @dynamic_attribute def title_name ( self ) -> str : \"\"\"The human-readable name of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return create_title ( self . __enum_checked_name__ ) enum_generate_next_value = staticmethod ( incremental_next_value )","title":"Enum"},{"location":"reference/enums/#enum_extensions.enums.Enum.__new__","text":"Looks up the member by value. Example >>> Color ( 1 ) < Color . RED : 1 > Parameters: Name Type Description Default value Any The value to search for. required Raises: Type Description ValueError The member was not found. Returns: Type Description EnumT The Enum member found. Source code in enum_extensions/enums.py 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 def __new__ ( cls : Type [ EnumT ], value : Any ) -> EnumT : \"\"\"Looks up the member by value. Example: ```python >>> Color(1) <Color.RED: 1> ``` Arguments: value: The value to search for. Raises: ValueError: The member was not found. Returns: The [`Enum`][enum_extensions.enums.Enum] member found. \"\"\" # all enum members are created during type construction without calling this method if type ( value ) is cls : return value try : return cls . _value_mapping [ value ] except KeyError : # not found, no need to do O(n) search pass except TypeError : # not hashable, then do long search, O(n) behavior for member in cls . _member_mapping . values (): if member . __enum_value__ == value : return member error = None # still not found -> try enum_missing hook try : result = cls . enum_missing ( value ) # type: ignore except AttributeError : # pragma: no cover result = None except Exception as error_happened : error = error_happened result = None if is_instance ( result , cls ): return result else : error_invalid = ValueError ( INVALID_VALUE . format ( repr ( value ), tick ( get_name ( cls )))) if result is None and error is None : # no result, no error raise error_invalid if error is None : error = ValueError ( ENUM_MISSING_ERROR . format ( get_name ( cls ), repr ( result ))) raise error_invalid from error","title":"__new__()"},{"location":"reference/enums/#enum_extensions.enums.Enum.__repr__","text":"Returns the string used by repr calls. By default contains the Enum name along with member name and value. Example >>> Color . BLUE < Color . BLUE : 3 > Returns: Type Description str The string used in the repr function. Source code in enum_extensions/enums.py 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name along with member name and value. Example: ```python >>> Color.BLUE <Color.BLUE: 3> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return ENUM_MEMBER_REPRESENTATION . format ( get_name ( type ( self )), self . __enum_checked_name__ , self . __enum_value__ )","title":"__repr__()"},{"location":"reference/enums/#enum_extensions.enums.Enum.__str__","text":"Returns the string used by str calls. By default contains the Enum name along with member name. Example >>> print ( Color . BLUE ) Color . BLUE Returns: Type Description str The string used in the str function. Source code in enum_extensions/enums.py 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 def __str__ ( self ) -> str : \"\"\"Returns the string used by [`str`][str] calls. By default contains the [`Enum`][enum_extensions.enums.Enum] name along with member name. Example: ```python >>> print(Color.BLUE) Color.BLUE ``` Returns: The string used in the [`str`][str] function. \"\"\" return ENUM_MEMBER_STRING . format ( get_name ( type ( self )), self . __enum_checked_name__ )","title":"__str__()"},{"location":"reference/enums/#enum_extensions.enums.Enum.__format__","text":"Returns the string used by format calls and f-strings. By default this function gives the same result as str does. Example >>> color = Color . RED >>> print ( f \" { color } \" ) Color . RED Returns: Type Description str The string used in the format function and f-strings. Source code in enum_extensions/enums.py 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 def __format__ ( self , specification : str ) -> str : \"\"\"Returns the string used by [`format`][format] calls and f-strings. By default this function gives the same result as [`str`][str] does. Example: ```python >>> color = Color.RED >>> print(f\"{color}\") Color.RED ``` Returns: The string used in the [`format`][format] function and f-strings. \"\"\" data_type = self . _data_type if data_type is object : type , value = str , str ( self ) else : type , value = data_type , self . __enum_value__ return type . __format__ ( value , specification )","title":"__format__()"},{"location":"reference/enums/#enum_extensions.enums.Enum.name","text":"The name of the Enum member. Source code in enum_extensions/enums.py 1472 1473 1474 1475 @dynamic_attribute def name ( self ) -> str : \"\"\"The name of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return self . __enum_checked_name__","title":"name()"},{"location":"reference/enums/#enum_extensions.enums.Enum.value","text":"The value of the Enum member. Source code in enum_extensions/enums.py 1477 1478 1479 1480 @dynamic_attribute def value ( self ) -> Any : \"\"\"The value of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return self . __enum_value__","title":"value()"},{"location":"reference/enums/#enum_extensions.enums.Enum.title_name","text":"The human-readable name of the Enum member. Source code in enum_extensions/enums.py 1482 1483 1484 1485 @dynamic_attribute def title_name ( self ) -> str : \"\"\"The human-readable name of the [`Enum`][enum_extensions.enums.Enum] member.\"\"\" return create_title ( self . __enum_checked_name__ )","title":"title_name()"},{"location":"reference/enums/#enum_extensions.enums.IntEnum","text":"Bases: int , Enum An enumeration whose values are (and must be) integers. Source code in enum_extensions/enums.py 1507 1508 class IntEnum ( int , Enum ): \"\"\"An enumeration whose values are (and must be) integers.\"\"\"","title":"IntEnum"},{"location":"reference/enums/#enum_extensions.enums.StringEnum","text":"Bases: str , Enum An enumeration whose values are (and must be) strings. Source code in enum_extensions/enums.py 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 class StringEnum ( str , Enum ): \"\"\"An enumeration whose values are (and must be) strings.\"\"\" @overload def __new__ ( cls : Type [ S ], item : buffer , encoding : str = ... , errors : str = ... ) -> S : ... @overload def __new__ ( cls : Type [ S ], item : Any ) -> S : ... def __new__ ( cls : Type [ S ], item : Any , encoding : str = UTF_8 , errors : str = STRICT ) -> S : if is_string ( item ): value = item else : # pragma: no cover value = str ( item , encoding , errors ) member = str . __new__ ( cls , value ) member . __enum_value__ = value return member enum_generate_next_value = staticmethod ( case_fold_name_next_value )","title":"StringEnum"},{"location":"reference/enums/#enum_extensions.enums.enum_generate_next_value","text":"Generates an appropriate next value to use. Parameters: Name Type Description Default name Optional [ str ] The name of the Enum member which needs a value. required start Optional [ T ] An initial value to use. required count int The amount of already existing unique enumeration members. required values Sequence [ T ] All previously defined members. required Returns: Type Description T The generated value. Source code in enum_extensions/enums.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def enum_generate_next_value ( name : Optional [ str ], start : Optional [ T ], count : int , values : Sequence [ T ] ) -> T : \"\"\"Generates an appropriate next value to use. Arguments: name: The name of the [`Enum`][enum_extensions.enums.Enum] member which needs a value. start: An initial value to use. count: The amount of already existing unique enumeration members. values: All previously defined members. Returns: The generated value. \"\"\" raise NotImplementedError","title":"enum_generate_next_value()"},{"location":"reference/flags/","text":"FlagBoundary Bases: StringEnum Controls how out-of-range values are handled in Flag types. Source code in enum_extensions/flags.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 class FlagBoundary ( StringEnum ): \"\"\"Controls how *out-of-range* values are handled in [`Flag`][enum_extensions.flags.Flag] types. \"\"\" STRICT = auto () \"\"\"*Out-of-range* values cause [`ValueError`][ValueError]. This is the default for [`Flag`][enum_extensions.flags.Flag]. Example: ```python from enum_extensions import STRICT, Flag class StrictFlag(Flag, boundary=STRICT): RED = auto() GREEN = auto() BLUE = auto() ``` ```python >>> StrictFlag((1 << 2) + (1 << 4)) Traceback (most recent call last): ... ValueError: invalid value 0x14 in `StrictFlag`: given 0b0 10100 allowed 0b0 00111 ``` \"\"\" CONFORM = auto () \"\"\"*Out-of-range* values have invalid values removed, leaving a valid [`Flag`][enum_extensions.flags.Flag] member. Example: ```python from enum_extensions import CONFORM, Flag class ConformFlag(Flag, boundary=CONFORM): RED = auto() GREEN = auto() BLUE = auto() ``` ```python >>> ConformFlag((1 << 2) + (1 << 4)) <ConformFlag.BLUE: 4> ``` \"\"\" KEEP = auto () \"\"\"*Out-of-range* values are kept along with the [`Flag`][enum_extensions.flags.Flag] membership. This is the default for [`IntFlag`][enum_extensions.flags.IntFlag]. Example: ```python from enum_extensions import KEEP, Flag class KeepFlag(Flag, boundary=KEEP): RED = auto() GREEN = auto() BLUE = auto() ``` ```python >>> KeepFlag((1 << 2) + (1 << 4)) <KeepFlag.BLUE|0x10: 4> ``` \"\"\" STRICT = auto () class-attribute Out-of-range values cause ValueError . This is the default for Flag . Example from enum_extensions import STRICT , Flag class StrictFlag ( Flag , boundary = STRICT ): RED = auto () GREEN = auto () BLUE = auto () >>> StrictFlag (( 1 << 2 ) + ( 1 << 4 )) Traceback ( most recent call last ): ... ValueError : invalid value 0x14 in ` StrictFlag ` : given 0b0 10100 allowed 0b0 00111 CONFORM = auto () class-attribute Out-of-range values have invalid values removed, leaving a valid Flag member. Example from enum_extensions import CONFORM , Flag class ConformFlag ( Flag , boundary = CONFORM ): RED = auto () GREEN = auto () BLUE = auto () >>> ConformFlag (( 1 << 2 ) + ( 1 << 4 )) < ConformFlag . BLUE : 4 > KEEP = auto () class-attribute Out-of-range values are kept along with the Flag membership. This is the default for IntFlag . Example from enum_extensions import KEEP , Flag class KeepFlag ( Flag , boundary = KEEP ): RED = auto () GREEN = auto () BLUE = auto () >>> KeepFlag (( 1 << 2 ) + ( 1 << 4 )) < KeepFlag . BLUE | 0x10 : 4 > FlagType Bases: EnumType Source code in enum_extensions/flags.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 class FlagType ( EnumType ): _member_values : List [ int ] _member_mapping : StringDict [ Flag ] # type: ignore _value_mapping : Dict [ int , Flag ] # type: ignore _flag_mask : int _full_mask : int _bit_length : int _boundary : FlagBoundary def __new__ ( cls : Type [ FT ], flag_name : str , bases : DynamicTuple [ AnyType ], namespace : EnumDict , * , ignore : Optional [ MaybeIterable [ str ]] = None , start : Optional [ int ] = None , boundary : Optional [ FlagBoundary ] = None , ** kwargs : Any , ) -> FT : new_flag_type = super () . __new__ ( cls , flag_name , bases , namespace , ignore = ignore , start = start , flag = True ) if boundary is None : boundary = get_attribute ( new_flag_type , BOUNDARY_PRIVATE , STRICT ) flag_mask = 0 for value in new_flag_type . _member_values : flag_mask |= value bit_length = flag_mask . bit_length () full_mask = bit_mask ( bit_length ) new_flag_type . _flag_mask = flag_mask new_flag_type . _full_mask = full_mask new_flag_type . _bit_length = bit_length new_flag_type . _boundary = boundary new_flag_type . _modify_mask_and_iter () return new_flag_type def _modify_mask_and_iter ( self ) -> None : single_bit_total = 0 multi_bit_total = 0 for flag in self . _member_mapping . values (): value = flag . __enum_value__ if is_single_bit ( value ): single_bit_total |= value else : multi_bit_total |= value # multi-bit flags are considered aliases if self . _boundary is not KEEP : missed = multi_bit_total & ~ single_bit_total if missed : raise TypeError ( INVALID_FLAG . format ( tick ( get_name ( self )), hex ( missed ))) self . _flag_mask = single_bit_total flag_list = [ flag . __enum_value__ for flag in self ] if sorted ( flag_list ) != flag_list : # definition order is not the same as increasing value order self . _iter_member = self . _iter_member_by_defintion @overload def __call__ ( self : Type [ F ], value : Any ) -> F : ... @overload def __call__ ( self : FT , value : str , names : Optional [ Names ] = ... , * , module : Optional [ str ] = ... , qualified_name : Optional [ str ] = ... , type : Optional [ AnyType ] = ... , start : Optional [ Any ] = ... , boundary : Optional [ FlagBoundary ] = ... , ** members : Any , ) -> FT : ... def __call__ ( self : Type [ F ], value : Any , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , boundary : Optional [ FlagBoundary ] = None , ** members : Any , ) -> Union [ F , Type [ F ]]: \"\"\"Looks up an existing member or creates a new flag. Example: Creation: ```python Color = Flag(\"Color\", RED=1, GREEN=2, BLUE=4) ``` Value lookup: ```python blue = Color(4) # <Color.BLUE: 4> ``` Arguments: value: The value to search for or the name of the new [`Flag`][enum_extensions.flags.Flag] to create. names: The names/values of the new flag members. module: The name of the module the [`Flag`][enum_extensions.flags.Flag] is created in. qualified_name: The actual location in the module where the flag can be found. type: A data type of the new [`Flag`][enum_extensions.flags.Flag]. start: The initial value of the new flag (used by [`auto`][enum_extensions.auto.auto]). boundary: The [`FlagBoundary`][enum_extensions.flags.FlagBoundary] to use. [`None`] means it should be inherited. The default boundary in the end is [`STRICT`][enum_extensions.flags.FlagBoundary.STRICT]. **members: A `name -> value` mapping of [`Flag`][enum_extensions.flags.Flag] members. Raises: ValueError: The member was not found. ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] type or a member found. \"\"\" if names or module or qualified_name or type or start or boundary or members : return self . create ( value , names , module = module , qualified_name = qualified_name , type = type , start = start , boundary = boundary , direct_call = False , ** members , ) return self . __new__ ( self , value ) def create ( self : FT , flag_name : str , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , boundary : Optional [ FlagBoundary ] = None , direct_call : bool = True , ** members : Any , ) -> FT : \"\"\"Creates a new flag. Example: ```python Color = Flag(\"Color\", (\"RED\", \"GREEN\", \"BLUE\")) ``` Arguments: flag_name: The name of the new [`Flag`][enum_extensions.flags.Flag] to create. names: The names/values of the new flag members. module: The name of the module the [`Flag`][enum_extensions.flags.Flag] is created in. qualified_name: The actual location in the module where the flag can be found. type: A data type of the new [`Flag`][enum_extensions.flags.Flag]. start: The initial value of the new flag (used by [`auto`][enum_extensions.auto.auto]). boundary: The [`FlagBoundary`][enum_extensions.flags.FlagBoundary] to use. [`None`][None] means it should be inherited. The default boundary in the end is [`STRICT`][enum_extensions.flags.FlagBoundary.STRICT]. direct_call: Controls if the function is called directly or not. This argument should be used with caution. **members: A `name -> value` mapping of [`Flag`][enum_extensions.flags.Flag] members. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] type. \"\"\" meta = standard_type ( self ) bases = ( self ,) if type is None else ( type , self ) enum_type = find_enum_type ( bases ) namespace = meta . __prepare__ ( flag_name , bases , start = start , boundary = boundary ) if names is not None : # special processing needed for strings if is_string ( names ): names = names . replace ( COMMA , SPACE ) . strip () . split () if is_mapping ( names ): namespace . update ( names ) else : iterator = iter ( names ) item = next ( iterator , null ) if is_not_null ( item ): iterator = prepend ( item , iterator ) if is_string ( item ): original_names , names = names , [] values = [] for count , name in enumerate ( original_names ): value = enum_type . enum_generate_next_value ( name , start , count , values . copy () ) values . append ( value ) names . append (( name , value )) iterator = iter ( names ) namespace . update ( iterator ) namespace . update ( members ) # TODO: replace the frame hack if a blessed way to know the calling # module is ever developed if module is None : try : module = get_frame ( DIRECT_CALLER if direct_call else NESTED_CALLER ) . f_globals [ NAME ] except ( AttributeError , ValueError , KeyError ): # pragma: no cover pass if module is None : # pragma: no cover make_namespace_unpicklable ( namespace ) else : namespace [ MODULE ] = module if qualified_name is None : if module is not None : qualified_name = QUALIFIED_NAME_STRING . format ( module , flag_name ) if qualified_name is not None : namespace [ QUALIFIED_NAME ] = qualified_name return meta . __new__ ( meta , flag_name , bases , namespace , boundary = boundary ) def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name. Example: ```python >>> Permission <flag `Permission`> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return FLAG_REPRESENTATION . format ( tick ( get_name ( self ))) def _iter_member_by_value ( self : Type [ F ], value : int ) -> Iterator [ F ]: value_mapping = self . _value_mapping for value in iter_bits ( value & self . _flag_mask ): yield value_mapping [ value ] _iter_member = _iter_member_by_value def _iter_member_by_defintion ( self : Type [ F ], value : int ) -> Iterator [ F ]: return iter ( sorted ( self . _iter_member_by_value ( value ), key = lambda flag : flag . _sort_order , ) ) def _prepare_names ( self , value : int ) -> Tuple [ List [ str ], int ]: flag_mask = self . _flag_mask unknown = value & ~ flag_mask value &= flag_mask names = [ flag . __enum_name__ for flag in self . _iter_member ( value )] return names , unknown def enum_missing ( self : Type [ F ], value : int ) -> F : \"\"\"Handles *out-of-range* `value` according to given boundary. Arguments: value: The value to handle. Raises: ValueError: An invalid value was given. Returns: The matching flag member. See [`FlagBoundary`][enum_extensions.flags.FlagBoundary] for more information. \"\"\" if not is_int ( value ): raise ValueError ( INVALID_VALUE . format ( repr ( value ), tick ( get_name ( self )))) flag_mask = self . _flag_mask all_bits = self . _full_mask bit_length = self . _bit_length boundary = self . _boundary negative_value : Optional [ int ] = None if ( # must be in range not ~ all_bits <= value <= all_bits # must not include any skipped flags or value & ( all_bits ^ flag_mask ) ): if boundary is STRICT : bits = max ( value . bit_length (), bit_length ) raise ValueError ( INVALID_BITS . format ( hex ( value ), tick ( get_name ( self )), bin ( value , bits ), bin ( flag_mask , bits ) ) ) elif boundary is CONFORM : value &= flag_mask elif boundary is KEEP : if value < 0 : negative_value = value value = bit_at ( max ( bit_length , value . bit_length ())) + value else : # pragma: no cover raise ValueError ( UNKNOWN_BOUNDARY . format ( repr ( boundary ))) if value < 0 : negative_value = value value += bit_at ( bit_length ) unknown = value & ~ flag_mask if unknown and boundary is not KEEP : # pragma: no cover # TODO: cover? raise ValueError ( UNKNOWN_VALUES . format ( get_name ( self ), value , unknown , bin ( unknown ))) member = self . add_member ( None , value ) if negative_value is not None : self . _value_mapping [ negative_value ] = member return member def add_member ( self : Type [ F ], name : Optional [ str ], value : int ) -> F : \"\"\"Adds a new member to the [`Flag`][enum_extensions.flags.Flag]. Example: ```python class Permission(Flag): R = 4 W = 2 X = 1 permission = Permission.add_member(\"N\", 0) # <Perm.N: 0> ``` Arguments: name: The name of a member. value: The value of a member. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] member. \"\"\" member = super () . add_member ( name , value ) self . _modify_mask_and_iter () return member def from_values ( self : Type [ F ], * values : int , bound : bool = True ) -> F : \"\"\"Searches for flag members by values, combining them into a single composite member. Example: ```python >>> Permission.from_values(4, 2) <Permission.R|W: 6> ``` Arguments: *values: The values to look up. bound: Whether to ignore invalid values. Raises: ValueError: An invalid value was encountered and `bound` is false. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) if bound : for value in values : result |= self . from_value ( value ) else : for value in values : result |= self . from_value ( value , 0 ) return result def from_names ( self : Type [ F ], * names : str ) -> F : \"\"\"Searches for flag members by names, combining them into a single composite member. Example: ```python >>> Permission.from_names(\"r\", \"w\", \"x\") <Permission.R|W|X: 7> ``` Arguments: *names: The names to look up. Raises: KeyError: An invalid name was encountered. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) for name in names : result |= self . from_name ( name ) return result def from_multiple_data ( self : Type [ F ], * multiple_data : Union [ int , str ], bound : bool = True ) -> F : \"\"\"Searches for flag members by names or values, combining them into a single composite member. Example: ```python >>> Permission.from_multiple_data(0, \"x\") <Permission.X: 1> ``` Arguments: *multiple_data: The names and values to look up. bound: Whether to ignore invalid entries. Raises: ValueError: Invalid data was encountered and `bound` is false. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) if bound : for data in multiple_data : result |= self . from_data ( data ) else : for data in multiple_data : result |= self . from_data ( data , 0 ) return result __call__ ( value , names = None , * , module = None , qualified_name = None , type = None , start = None , boundary = None , ** members ) Looks up an existing member or creates a new flag. Example Creation: Color = Flag ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 4 ) Value lookup: blue = Color ( 4 ) # <Color.BLUE: 4> Parameters: Name Type Description Default value Any The value to search for or the name of the new Flag to create. required names Optional [ Names ] The names/values of the new flag members. None module Optional [ str ] The name of the module the Flag is created in. None qualified_name Optional [ str ] The actual location in the module where the flag can be found. None type Optional [ AnyType ] A data type of the new Flag . None start Optional [ Any ] The initial value of the new flag (used by auto ). None boundary Optional [ FlagBoundary ] The FlagBoundary to use. [ None ] means it should be inherited. The default boundary in the end is STRICT . None **members Any A name -> value mapping of Flag members. {} Raises: Type Description ValueError The member was not found. ValueError The name is already used by another member. Returns: Type Description Union [ F , Type [ F ]] A newly created Flag type or a member found. Source code in enum_extensions/flags.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def __call__ ( self : Type [ F ], value : Any , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , boundary : Optional [ FlagBoundary ] = None , ** members : Any , ) -> Union [ F , Type [ F ]]: \"\"\"Looks up an existing member or creates a new flag. Example: Creation: ```python Color = Flag(\"Color\", RED=1, GREEN=2, BLUE=4) ``` Value lookup: ```python blue = Color(4) # <Color.BLUE: 4> ``` Arguments: value: The value to search for or the name of the new [`Flag`][enum_extensions.flags.Flag] to create. names: The names/values of the new flag members. module: The name of the module the [`Flag`][enum_extensions.flags.Flag] is created in. qualified_name: The actual location in the module where the flag can be found. type: A data type of the new [`Flag`][enum_extensions.flags.Flag]. start: The initial value of the new flag (used by [`auto`][enum_extensions.auto.auto]). boundary: The [`FlagBoundary`][enum_extensions.flags.FlagBoundary] to use. [`None`] means it should be inherited. The default boundary in the end is [`STRICT`][enum_extensions.flags.FlagBoundary.STRICT]. **members: A `name -> value` mapping of [`Flag`][enum_extensions.flags.Flag] members. Raises: ValueError: The member was not found. ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] type or a member found. \"\"\" if names or module or qualified_name or type or start or boundary or members : return self . create ( value , names , module = module , qualified_name = qualified_name , type = type , start = start , boundary = boundary , direct_call = False , ** members , ) return self . __new__ ( self , value ) create ( flag_name , names = None , * , module = None , qualified_name = None , type = None , start = None , boundary = None , direct_call = True , ** members ) Creates a new flag. Example Color = Flag ( \"Color\" , ( \"RED\" , \"GREEN\" , \"BLUE\" )) Parameters: Name Type Description Default flag_name str The name of the new Flag to create. required names Optional [ Names ] The names/values of the new flag members. None module Optional [ str ] The name of the module the Flag is created in. None qualified_name Optional [ str ] The actual location in the module where the flag can be found. None type Optional [ AnyType ] A data type of the new Flag . None start Optional [ Any ] The initial value of the new flag (used by auto ). None boundary Optional [ FlagBoundary ] The FlagBoundary to use. None means it should be inherited. The default boundary in the end is STRICT . None direct_call bool Controls if the function is called directly or not. This argument should be used with caution. True **members Any A name -> value mapping of Flag members. {} Raises: Type Description ValueError The name is already used by another member. Returns: Type Description FT A newly created Flag type. Source code in enum_extensions/flags.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def create ( self : FT , flag_name : str , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , boundary : Optional [ FlagBoundary ] = None , direct_call : bool = True , ** members : Any , ) -> FT : \"\"\"Creates a new flag. Example: ```python Color = Flag(\"Color\", (\"RED\", \"GREEN\", \"BLUE\")) ``` Arguments: flag_name: The name of the new [`Flag`][enum_extensions.flags.Flag] to create. names: The names/values of the new flag members. module: The name of the module the [`Flag`][enum_extensions.flags.Flag] is created in. qualified_name: The actual location in the module where the flag can be found. type: A data type of the new [`Flag`][enum_extensions.flags.Flag]. start: The initial value of the new flag (used by [`auto`][enum_extensions.auto.auto]). boundary: The [`FlagBoundary`][enum_extensions.flags.FlagBoundary] to use. [`None`][None] means it should be inherited. The default boundary in the end is [`STRICT`][enum_extensions.flags.FlagBoundary.STRICT]. direct_call: Controls if the function is called directly or not. This argument should be used with caution. **members: A `name -> value` mapping of [`Flag`][enum_extensions.flags.Flag] members. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] type. \"\"\" meta = standard_type ( self ) bases = ( self ,) if type is None else ( type , self ) enum_type = find_enum_type ( bases ) namespace = meta . __prepare__ ( flag_name , bases , start = start , boundary = boundary ) if names is not None : # special processing needed for strings if is_string ( names ): names = names . replace ( COMMA , SPACE ) . strip () . split () if is_mapping ( names ): namespace . update ( names ) else : iterator = iter ( names ) item = next ( iterator , null ) if is_not_null ( item ): iterator = prepend ( item , iterator ) if is_string ( item ): original_names , names = names , [] values = [] for count , name in enumerate ( original_names ): value = enum_type . enum_generate_next_value ( name , start , count , values . copy () ) values . append ( value ) names . append (( name , value )) iterator = iter ( names ) namespace . update ( iterator ) namespace . update ( members ) # TODO: replace the frame hack if a blessed way to know the calling # module is ever developed if module is None : try : module = get_frame ( DIRECT_CALLER if direct_call else NESTED_CALLER ) . f_globals [ NAME ] except ( AttributeError , ValueError , KeyError ): # pragma: no cover pass if module is None : # pragma: no cover make_namespace_unpicklable ( namespace ) else : namespace [ MODULE ] = module if qualified_name is None : if module is not None : qualified_name = QUALIFIED_NAME_STRING . format ( module , flag_name ) if qualified_name is not None : namespace [ QUALIFIED_NAME ] = qualified_name return meta . __new__ ( meta , flag_name , bases , namespace , boundary = boundary ) __repr__ () Returns the string used by repr calls. By default contains the Flag name. Example >>> Permission < flag ` Permission ` > Returns: Type Description str The string used in the repr function. Source code in enum_extensions/flags.py 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name. Example: ```python >>> Permission <flag `Permission`> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return FLAG_REPRESENTATION . format ( tick ( get_name ( self ))) enum_missing ( value ) Handles out-of-range value according to given boundary. Parameters: Name Type Description Default value int The value to handle. required Raises: Type Description ValueError An invalid value was given. Returns: Type Description F The matching flag member. See FlagBoundary F for more information. Source code in enum_extensions/flags.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def enum_missing ( self : Type [ F ], value : int ) -> F : \"\"\"Handles *out-of-range* `value` according to given boundary. Arguments: value: The value to handle. Raises: ValueError: An invalid value was given. Returns: The matching flag member. See [`FlagBoundary`][enum_extensions.flags.FlagBoundary] for more information. \"\"\" if not is_int ( value ): raise ValueError ( INVALID_VALUE . format ( repr ( value ), tick ( get_name ( self )))) flag_mask = self . _flag_mask all_bits = self . _full_mask bit_length = self . _bit_length boundary = self . _boundary negative_value : Optional [ int ] = None if ( # must be in range not ~ all_bits <= value <= all_bits # must not include any skipped flags or value & ( all_bits ^ flag_mask ) ): if boundary is STRICT : bits = max ( value . bit_length (), bit_length ) raise ValueError ( INVALID_BITS . format ( hex ( value ), tick ( get_name ( self )), bin ( value , bits ), bin ( flag_mask , bits ) ) ) elif boundary is CONFORM : value &= flag_mask elif boundary is KEEP : if value < 0 : negative_value = value value = bit_at ( max ( bit_length , value . bit_length ())) + value else : # pragma: no cover raise ValueError ( UNKNOWN_BOUNDARY . format ( repr ( boundary ))) if value < 0 : negative_value = value value += bit_at ( bit_length ) unknown = value & ~ flag_mask if unknown and boundary is not KEEP : # pragma: no cover # TODO: cover? raise ValueError ( UNKNOWN_VALUES . format ( get_name ( self ), value , unknown , bin ( unknown ))) member = self . add_member ( None , value ) if negative_value is not None : self . _value_mapping [ negative_value ] = member return member add_member ( name , value ) Adds a new member to the Flag . Example class Permission ( Flag ): R = 4 W = 2 X = 1 permission = Permission . add_member ( \"N\" , 0 ) # <Perm.N: 0> Parameters: Name Type Description Default name Optional [ str ] The name of a member. required value int The value of a member. required Raises: Type Description ValueError The name is already used by another member. Returns: Type Description F A newly created Flag member. Source code in enum_extensions/flags.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 def add_member ( self : Type [ F ], name : Optional [ str ], value : int ) -> F : \"\"\"Adds a new member to the [`Flag`][enum_extensions.flags.Flag]. Example: ```python class Permission(Flag): R = 4 W = 2 X = 1 permission = Permission.add_member(\"N\", 0) # <Perm.N: 0> ``` Arguments: name: The name of a member. value: The value of a member. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] member. \"\"\" member = super () . add_member ( name , value ) self . _modify_mask_and_iter () return member from_values ( * values , bound = True ) Searches for flag members by values, combining them into a single composite member. Example >>> Permission . from_values ( 4 , 2 ) < Permission . R | W : 6 > Parameters: Name Type Description Default *values int The values to look up. () bound bool Whether to ignore invalid values. True Raises: Type Description ValueError An invalid value was encountered and bound is false. Returns: Type Description F The combined Flag member. Source code in enum_extensions/flags.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 def from_values ( self : Type [ F ], * values : int , bound : bool = True ) -> F : \"\"\"Searches for flag members by values, combining them into a single composite member. Example: ```python >>> Permission.from_values(4, 2) <Permission.R|W: 6> ``` Arguments: *values: The values to look up. bound: Whether to ignore invalid values. Raises: ValueError: An invalid value was encountered and `bound` is false. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) if bound : for value in values : result |= self . from_value ( value ) else : for value in values : result |= self . from_value ( value , 0 ) return result from_names ( * names ) Searches for flag members by names, combining them into a single composite member. Example >>> Permission . from_names ( \"r\" , \"w\" , \"x\" ) < Permission . R | W | X : 7 > Parameters: Name Type Description Default *names str The names to look up. () Raises: Type Description KeyError An invalid name was encountered. Returns: Type Description F The combined Flag member. Source code in enum_extensions/flags.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 def from_names ( self : Type [ F ], * names : str ) -> F : \"\"\"Searches for flag members by names, combining them into a single composite member. Example: ```python >>> Permission.from_names(\"r\", \"w\", \"x\") <Permission.R|W|X: 7> ``` Arguments: *names: The names to look up. Raises: KeyError: An invalid name was encountered. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) for name in names : result |= self . from_name ( name ) return result from_multiple_data ( * multiple_data , bound = True ) Searches for flag members by names or values, combining them into a single composite member. Example >>> Permission . from_multiple_data ( 0 , \"x\" ) < Permission . X : 1 > Parameters: Name Type Description Default *multiple_data Union [ int , str ] The names and values to look up. () bound bool Whether to ignore invalid entries. True Raises: Type Description ValueError Invalid data was encountered and bound is false. Returns: Type Description F The combined Flag member. Source code in enum_extensions/flags.py 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 def from_multiple_data ( self : Type [ F ], * multiple_data : Union [ int , str ], bound : bool = True ) -> F : \"\"\"Searches for flag members by names or values, combining them into a single composite member. Example: ```python >>> Permission.from_multiple_data(0, \"x\") <Permission.X: 1> ``` Arguments: *multiple_data: The names and values to look up. bound: Whether to ignore invalid entries. Raises: ValueError: Invalid data was encountered and `bound` is false. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) if bound : for data in multiple_data : result |= self . from_data ( data ) else : for data in multiple_data : result |= self . from_data ( data , 0 ) return result Flag Bases: Enum Support for bit flags. Source code in enum_extensions/flags.py 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 class Flag ( Enum , metaclass = FlagType ): \"\"\"Support for bit flags.\"\"\" __enum_value__ : int def __iter__ ( self : FlagT ) -> Iterator [ FlagT ]: \"\"\"Returns an iterator over invididual (single-bit) flag members. Example: ```python >>> tuple(Permission.R | Permission.W) (<Permission.R: 4>, <Permission.W: 2>) ``` Returns: An iterator over single-bit [`Flag`][enum_extensions.flags.Flag] members. \"\"\" return type ( self ) . _iter_member ( self . __enum_value__ ) def __contains__ ( self : FlagT , flag : FlagT ) -> bool : \"\"\"Checks whether the `flag` is in [`Flag`][enum_extensions.flags.Flag]. Example: ```python >>> rw = Permission.R | Permission.W >>> x = Permission.X >>> assert x not in rw ``` Arguments: flag: The flag member to check. Raises: TypeError: `flag` is not an instance of [`Flag`][enum_extensions.flags.Flag]. Returns: Whether the `flag` is contained in [`Flag`][enum_extensions.flags.Flag]. \"\"\" if not is_flag_member ( flag ): raise TypeError ( UNSUPPORTED_IN . format ( tick ( get_name ( type ( flag ))), tick ( get_name ( type ( self )))) ) self_value = self . __enum_value__ flag_value = flag . __enum_value__ if not self_value or not flag_value : return False return is_same_type ( flag , self ) and flag_value & self_value == flag_value def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name along with the (composite) member name and value. Example: ```python >>> Permission.R | Permission.W | Permission.X <Permission.R|W|X: 7> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return FLAG_MEMBER_REPRESENTATION . format ( get_name ( type ( self )), self . __enum_composite_name__ , self . __enum_value__ ) def __str__ ( self ) -> str : \"\"\"Returns the string used by [`str`][str] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name along with the (composite) member name. Example: ```python >>> print(Permission.R | Permission.X) Permission.R|X ``` Returns: The string used in the [`str`][str] function. \"\"\" return FLAG_MEMBER_STRING . format ( get_name ( type ( self )), self . __enum_composite_name__ ) def __len__ ( self ) -> int : \"\"\"Returns the number of bits in the member value. Example: ```python >>> len(Permission.N) 0 >>> len(Permission.R | Permission.W | Permission.X) 3 ``` Returns: The bit count of the member value. \"\"\" return bit_count ( self . __enum_value__ ) def __bool__ ( self ) -> bool : \"\"\"Checks whether the value is non-zero. Returns: Whether the value is non-zero. \"\"\" return bool ( self . __enum_value__ ) def __or__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `|` (*OR*) operation. Example: ```python >>> Permission.R | Permission.X <Permission.R|X: 5> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ | other . __enum_value__ ) return NotImplemented def __and__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `&` (*AND*) operation. Example: ```python >>> Permission.X & (Permission.R | Permission.W) <Permission.N: 0> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ & other . __enum_value__ ) return NotImplemented def __xor__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `^` (*XOR*) operation. Example: ```python >>> (Permission.R | Permission.X) ^ (Permission.W | Permission.X) <Permission.R|W: 6> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ ^ other . __enum_value__ ) return NotImplemented def __invert__ ( self : FlagT ) -> FlagT : \"\"\"Inverts (`~`) the [`Flag`][enum_extensions.flags.Flag] member value. Example: ```python >>> ~Permission.N <Permission.R|W|X: 7> ``` Returns: The inverted [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if self . _boundary is KEEP : return type ( self )( ~ self . __enum_value__ ) return type ( self )( self . __enum_value__ ^ self . _flag_mask ) __ior__ = __or__ __iand__ = __and__ __ixor__ = __xor__ __ror__ = __or__ __rand__ = __and__ __rxor__ = __xor__ enum_generate_next_value = staticmethod ( strict_bit_next_value ) @dynamic_attribute def __enum_composite_name__ ( self ) -> str : name = self . __enum_name__ if name is None : value = self . __enum_value__ if not value : return str ( value ) names , unknown = type ( self ) . _prepare_names ( value ) if not names : return hex ( unknown ) if unknown : names . append ( hex ( unknown )) return concat_pipe ( names ) return name @dynamic_attribute def __enum_composite_title_name__ ( self ) -> str : name = self . __enum_name__ if name is None : value = self . __enum_value__ if not value : return str ( value ) names , unknown = type ( self ) . _prepare_names ( value ) if not names : return hex ( unknown ) title = concat_comma_space ( map ( create_title , names )) if unknown : return title + SPACE + NOT_COVERED . format ( hex ( unknown )) return title return create_title ( name ) @dynamic_attribute def name ( self ) -> str : \"\"\"The name of the [`Flag`][enum_extensions.flags.Flag] member.\"\"\" return self . __enum_composite_name__ @dynamic_attribute def title_name ( self ) -> str : \"\"\"The human-readable name of the [`Flag`][enum_extensions.flags.Flag] member.\"\"\" return self . __enum_composite_title_name__ __iter__ () Returns an iterator over invididual (single-bit) flag members. Example >>> tuple ( Permission . R | Permission . W ) ( < Permission . R : 4 > , < Permission . W : 2 > ) Returns: Type Description Iterator [ FlagT ] An iterator over single-bit Flag members. Source code in enum_extensions/flags.py 681 682 683 684 685 686 687 688 689 690 691 692 693 def __iter__ ( self : FlagT ) -> Iterator [ FlagT ]: \"\"\"Returns an iterator over invididual (single-bit) flag members. Example: ```python >>> tuple(Permission.R | Permission.W) (<Permission.R: 4>, <Permission.W: 2>) ``` Returns: An iterator over single-bit [`Flag`][enum_extensions.flags.Flag] members. \"\"\" return type ( self ) . _iter_member ( self . __enum_value__ ) __contains__ ( flag ) Checks whether the flag is in Flag . Example >>> rw = Permission . R | Permission . W >>> x = Permission . X >>> assert x not in rw Parameters: Name Type Description Default flag FlagT The flag member to check. required Raises: Type Description TypeError flag is not an instance of Flag . Returns: Type Description bool Whether the flag is contained in Flag . Source code in enum_extensions/flags.py 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 def __contains__ ( self : FlagT , flag : FlagT ) -> bool : \"\"\"Checks whether the `flag` is in [`Flag`][enum_extensions.flags.Flag]. Example: ```python >>> rw = Permission.R | Permission.W >>> x = Permission.X >>> assert x not in rw ``` Arguments: flag: The flag member to check. Raises: TypeError: `flag` is not an instance of [`Flag`][enum_extensions.flags.Flag]. Returns: Whether the `flag` is contained in [`Flag`][enum_extensions.flags.Flag]. \"\"\" if not is_flag_member ( flag ): raise TypeError ( UNSUPPORTED_IN . format ( tick ( get_name ( type ( flag ))), tick ( get_name ( type ( self )))) ) self_value = self . __enum_value__ flag_value = flag . __enum_value__ if not self_value or not flag_value : return False return is_same_type ( flag , self ) and flag_value & self_value == flag_value __repr__ () Returns the string used by repr calls. By default contains the Flag name along with the (composite) member name and value. Example >>> Permission . R | Permission . W | Permission . X < Permission . R | W | X : 7 > Returns: Type Description str The string used in the repr function. Source code in enum_extensions/flags.py 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name along with the (composite) member name and value. Example: ```python >>> Permission.R | Permission.W | Permission.X <Permission.R|W|X: 7> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return FLAG_MEMBER_REPRESENTATION . format ( get_name ( type ( self )), self . __enum_composite_name__ , self . __enum_value__ ) __str__ () Returns the string used by str calls. By default contains the Flag name along with the (composite) member name. Example >>> print ( Permission . R | Permission . X ) Permission . R | X Returns: Type Description str The string used in the str function. Source code in enum_extensions/flags.py 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 def __str__ ( self ) -> str : \"\"\"Returns the string used by [`str`][str] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name along with the (composite) member name. Example: ```python >>> print(Permission.R | Permission.X) Permission.R|X ``` Returns: The string used in the [`str`][str] function. \"\"\" return FLAG_MEMBER_STRING . format ( get_name ( type ( self )), self . __enum_composite_name__ ) __len__ () Returns the number of bits in the member value. Example >>> len ( Permission . N ) 0 >>> len ( Permission . R | Permission . W | Permission . X ) 3 Returns: Type Description int The bit count of the member value. Source code in enum_extensions/flags.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 def __len__ ( self ) -> int : \"\"\"Returns the number of bits in the member value. Example: ```python >>> len(Permission.N) 0 >>> len(Permission.R | Permission.W | Permission.X) 3 ``` Returns: The bit count of the member value. \"\"\" return bit_count ( self . __enum_value__ ) __bool__ () Checks whether the value is non-zero. Returns: Type Description bool Whether the value is non-zero. Source code in enum_extensions/flags.py 780 781 782 783 784 785 786 def __bool__ ( self ) -> bool : \"\"\"Checks whether the value is non-zero. Returns: Whether the value is non-zero. \"\"\" return bool ( self . __enum_value__ ) __or__ ( other ) Combines values of flag members via the | ( OR ) operation. Example >>> Permission . R | Permission . X < Permission . R | X : 5 > Parameters: Name Type Description Default other FlagT The flag member to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 def __or__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `|` (*OR*) operation. Example: ```python >>> Permission.R | Permission.X <Permission.R|X: 5> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ | other . __enum_value__ ) return NotImplemented __and__ ( other ) Combines values of flag members via the & ( AND ) operation. Example >>> Permission . X & ( Permission . R | Permission . W ) < Permission . N : 0 > Parameters: Name Type Description Default other FlagT The flag member to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 def __and__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `&` (*AND*) operation. Example: ```python >>> Permission.X & (Permission.R | Permission.W) <Permission.N: 0> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ & other . __enum_value__ ) return NotImplemented __xor__ ( other ) Combines values of flag members via the ^ ( XOR ) operation. Example >>> ( Permission . R | Permission . X ) ^ ( Permission . W | Permission . X ) < Permission . R | W : 6 > Parameters: Name Type Description Default other FlagT The flag member to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 def __xor__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `^` (*XOR*) operation. Example: ```python >>> (Permission.R | Permission.X) ^ (Permission.W | Permission.X) <Permission.R|W: 6> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ ^ other . __enum_value__ ) return NotImplemented __invert__ () Inverts ( ~ ) the Flag member value. Example >>> ~ Permission . N < Permission . R | W | X : 7 > Returns: Type Description FlagT The inverted Flag member. Source code in enum_extensions/flags.py 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 def __invert__ ( self : FlagT ) -> FlagT : \"\"\"Inverts (`~`) the [`Flag`][enum_extensions.flags.Flag] member value. Example: ```python >>> ~Permission.N <Permission.R|W|X: 7> ``` Returns: The inverted [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if self . _boundary is KEEP : return type ( self )( ~ self . __enum_value__ ) return type ( self )( self . __enum_value__ ^ self . _flag_mask ) name () The name of the Flag member. Source code in enum_extensions/flags.py 924 925 926 927 928 @dynamic_attribute def name ( self ) -> str : \"\"\"The name of the [`Flag`][enum_extensions.flags.Flag] member.\"\"\" return self . __enum_composite_name__ title_name () The human-readable name of the Flag member. Source code in enum_extensions/flags.py 930 931 932 933 934 @dynamic_attribute def title_name ( self ) -> str : \"\"\"The human-readable name of the [`Flag`][enum_extensions.flags.Flag] member.\"\"\" return self . __enum_composite_title_name__ IntFlag Bases: int , Flag Support for integer-like bit flags. Source code in enum_extensions/flags.py 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 class IntFlag ( int , Flag , boundary = KEEP ): \"\"\"Support for integer-like bit flags.\"\"\" def __contains__ ( self : FlagT , other : Union [ int , FlagT ]) -> bool : \"\"\"Checks whether `other` is in [`Flag`][enum_extensions.flags.Flag]. Example: ```python IntPermission = IntFlag(\"IntPermission\", R=4, W=2, X=1, N=0) r, w, x, n = IntPermission rx = r | x assert r in rx assert not w in rx assert x.value in rx ``` Arguments: other: The flag member or value to check. Raises: TypeError: `other` is not an [`int`][int] or a [`Flag`][enum_extensions.flags.Flag] member. Returns: Whether `other` is contained in [`Flag`][enum_extensions.flags.Flag]. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __contains__ ( other ) def __or__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `|` (*OR*) operation. Example: ```python >>> IntPermission.R | 2 <IntPermission.R|W: 6> >>> IntPermission.W | IntPermission.X <IntPermission.W|X: 2> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __or__ ( other ) def __and__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `&` (*AND*) operation. Example: ```python >>> IntPermission.W & (IntPermission.R | IntPermission.X) <IntPermission.N: 0> >>> IntPermission.X & 1 <IntPermission.X: 1> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __and__ ( other ) def __xor__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `^` (*XOR*) operation. Example: ```python >>> (IntPermission.W | IntPermission.X) ^ (IntPermission.R | IntPermission.X) <IntPermission.R|W: 6> >>> IntPermission.X ^ 1 <IntPermission.N: 0> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __xor__ ( other ) __ior__ = __or__ __iand__ = __and__ __ixor__ = __xor__ __ror__ = __or__ __rand__ = __and__ __rxor__ = __xor__ __contains__ ( other ) Checks whether other is in Flag . Example IntPermission = IntFlag ( \"IntPermission\" , R = 4 , W = 2 , X = 1 , N = 0 ) r , w , x , n = IntPermission rx = r | x assert r in rx assert not w in rx assert x . value in rx Parameters: Name Type Description Default other Union [ int , FlagT ] The flag member or value to check. required Raises: Type Description TypeError other is not an int or a Flag member. Returns: Type Description bool Whether other is contained in Flag . Source code in enum_extensions/flags.py 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 def __contains__ ( self : FlagT , other : Union [ int , FlagT ]) -> bool : \"\"\"Checks whether `other` is in [`Flag`][enum_extensions.flags.Flag]. Example: ```python IntPermission = IntFlag(\"IntPermission\", R=4, W=2, X=1, N=0) r, w, x, n = IntPermission rx = r | x assert r in rx assert not w in rx assert x.value in rx ``` Arguments: other: The flag member or value to check. Raises: TypeError: `other` is not an [`int`][int] or a [`Flag`][enum_extensions.flags.Flag] member. Returns: Whether `other` is contained in [`Flag`][enum_extensions.flags.Flag]. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __contains__ ( other ) __or__ ( other ) Combines values (of flag members) via the | ( OR ) operation. Example >>> IntPermission . R | 2 < IntPermission . R | W : 6 > >>> IntPermission . W | IntPermission . X < IntPermission . W | X : 2 > Parameters: Name Type Description Default other Union [ int , FlagT ] The flag member or value to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 def __or__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `|` (*OR*) operation. Example: ```python >>> IntPermission.R | 2 <IntPermission.R|W: 6> >>> IntPermission.W | IntPermission.X <IntPermission.W|X: 2> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __or__ ( other ) __and__ ( other ) Combines values (of flag members) via the & ( AND ) operation. Example >>> IntPermission . W & ( IntPermission . R | IntPermission . X ) < IntPermission . N : 0 > >>> IntPermission . X & 1 < IntPermission . X : 1 > Parameters: Name Type Description Default other Union [ int , FlagT ] The flag member or value to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 def __and__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `&` (*AND*) operation. Example: ```python >>> IntPermission.W & (IntPermission.R | IntPermission.X) <IntPermission.N: 0> >>> IntPermission.X & 1 <IntPermission.X: 1> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __and__ ( other ) __xor__ ( other ) Combines values (of flag members) via the ^ ( XOR ) operation. Example >>> ( IntPermission . W | IntPermission . X ) ^ ( IntPermission . R | IntPermission . X ) < IntPermission . R | W : 6 > >>> IntPermission . X ^ 1 < IntPermission . N : 0 > Parameters: Name Type Description Default other Union [ int , FlagT ] The flag member or value to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def __xor__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `^` (*XOR*) operation. Example: ```python >>> (IntPermission.W | IntPermission.X) ^ (IntPermission.R | IntPermission.X) <IntPermission.R|W: 6> >>> IntPermission.X ^ 1 <IntPermission.N: 0> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __xor__ ( other )","title":"Flags"},{"location":"reference/flags/#enum_extensions.flags.FlagBoundary","text":"Bases: StringEnum Controls how out-of-range values are handled in Flag types. Source code in enum_extensions/flags.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 class FlagBoundary ( StringEnum ): \"\"\"Controls how *out-of-range* values are handled in [`Flag`][enum_extensions.flags.Flag] types. \"\"\" STRICT = auto () \"\"\"*Out-of-range* values cause [`ValueError`][ValueError]. This is the default for [`Flag`][enum_extensions.flags.Flag]. Example: ```python from enum_extensions import STRICT, Flag class StrictFlag(Flag, boundary=STRICT): RED = auto() GREEN = auto() BLUE = auto() ``` ```python >>> StrictFlag((1 << 2) + (1 << 4)) Traceback (most recent call last): ... ValueError: invalid value 0x14 in `StrictFlag`: given 0b0 10100 allowed 0b0 00111 ``` \"\"\" CONFORM = auto () \"\"\"*Out-of-range* values have invalid values removed, leaving a valid [`Flag`][enum_extensions.flags.Flag] member. Example: ```python from enum_extensions import CONFORM, Flag class ConformFlag(Flag, boundary=CONFORM): RED = auto() GREEN = auto() BLUE = auto() ``` ```python >>> ConformFlag((1 << 2) + (1 << 4)) <ConformFlag.BLUE: 4> ``` \"\"\" KEEP = auto () \"\"\"*Out-of-range* values are kept along with the [`Flag`][enum_extensions.flags.Flag] membership. This is the default for [`IntFlag`][enum_extensions.flags.IntFlag]. Example: ```python from enum_extensions import KEEP, Flag class KeepFlag(Flag, boundary=KEEP): RED = auto() GREEN = auto() BLUE = auto() ``` ```python >>> KeepFlag((1 << 2) + (1 << 4)) <KeepFlag.BLUE|0x10: 4> ``` \"\"\"","title":"FlagBoundary"},{"location":"reference/flags/#enum_extensions.flags.FlagBoundary.STRICT","text":"Out-of-range values cause ValueError . This is the default for Flag . Example from enum_extensions import STRICT , Flag class StrictFlag ( Flag , boundary = STRICT ): RED = auto () GREEN = auto () BLUE = auto () >>> StrictFlag (( 1 << 2 ) + ( 1 << 4 )) Traceback ( most recent call last ): ... ValueError : invalid value 0x14 in ` StrictFlag ` : given 0b0 10100 allowed 0b0 00111","title":"STRICT"},{"location":"reference/flags/#enum_extensions.flags.FlagBoundary.CONFORM","text":"Out-of-range values have invalid values removed, leaving a valid Flag member. Example from enum_extensions import CONFORM , Flag class ConformFlag ( Flag , boundary = CONFORM ): RED = auto () GREEN = auto () BLUE = auto () >>> ConformFlag (( 1 << 2 ) + ( 1 << 4 )) < ConformFlag . BLUE : 4 >","title":"CONFORM"},{"location":"reference/flags/#enum_extensions.flags.FlagBoundary.KEEP","text":"Out-of-range values are kept along with the Flag membership. This is the default for IntFlag . Example from enum_extensions import KEEP , Flag class KeepFlag ( Flag , boundary = KEEP ): RED = auto () GREEN = auto () BLUE = auto () >>> KeepFlag (( 1 << 2 ) + ( 1 << 4 )) < KeepFlag . BLUE | 0x10 : 4 >","title":"KEEP"},{"location":"reference/flags/#enum_extensions.flags.FlagType","text":"Bases: EnumType Source code in enum_extensions/flags.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 class FlagType ( EnumType ): _member_values : List [ int ] _member_mapping : StringDict [ Flag ] # type: ignore _value_mapping : Dict [ int , Flag ] # type: ignore _flag_mask : int _full_mask : int _bit_length : int _boundary : FlagBoundary def __new__ ( cls : Type [ FT ], flag_name : str , bases : DynamicTuple [ AnyType ], namespace : EnumDict , * , ignore : Optional [ MaybeIterable [ str ]] = None , start : Optional [ int ] = None , boundary : Optional [ FlagBoundary ] = None , ** kwargs : Any , ) -> FT : new_flag_type = super () . __new__ ( cls , flag_name , bases , namespace , ignore = ignore , start = start , flag = True ) if boundary is None : boundary = get_attribute ( new_flag_type , BOUNDARY_PRIVATE , STRICT ) flag_mask = 0 for value in new_flag_type . _member_values : flag_mask |= value bit_length = flag_mask . bit_length () full_mask = bit_mask ( bit_length ) new_flag_type . _flag_mask = flag_mask new_flag_type . _full_mask = full_mask new_flag_type . _bit_length = bit_length new_flag_type . _boundary = boundary new_flag_type . _modify_mask_and_iter () return new_flag_type def _modify_mask_and_iter ( self ) -> None : single_bit_total = 0 multi_bit_total = 0 for flag in self . _member_mapping . values (): value = flag . __enum_value__ if is_single_bit ( value ): single_bit_total |= value else : multi_bit_total |= value # multi-bit flags are considered aliases if self . _boundary is not KEEP : missed = multi_bit_total & ~ single_bit_total if missed : raise TypeError ( INVALID_FLAG . format ( tick ( get_name ( self )), hex ( missed ))) self . _flag_mask = single_bit_total flag_list = [ flag . __enum_value__ for flag in self ] if sorted ( flag_list ) != flag_list : # definition order is not the same as increasing value order self . _iter_member = self . _iter_member_by_defintion @overload def __call__ ( self : Type [ F ], value : Any ) -> F : ... @overload def __call__ ( self : FT , value : str , names : Optional [ Names ] = ... , * , module : Optional [ str ] = ... , qualified_name : Optional [ str ] = ... , type : Optional [ AnyType ] = ... , start : Optional [ Any ] = ... , boundary : Optional [ FlagBoundary ] = ... , ** members : Any , ) -> FT : ... def __call__ ( self : Type [ F ], value : Any , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , boundary : Optional [ FlagBoundary ] = None , ** members : Any , ) -> Union [ F , Type [ F ]]: \"\"\"Looks up an existing member or creates a new flag. Example: Creation: ```python Color = Flag(\"Color\", RED=1, GREEN=2, BLUE=4) ``` Value lookup: ```python blue = Color(4) # <Color.BLUE: 4> ``` Arguments: value: The value to search for or the name of the new [`Flag`][enum_extensions.flags.Flag] to create. names: The names/values of the new flag members. module: The name of the module the [`Flag`][enum_extensions.flags.Flag] is created in. qualified_name: The actual location in the module where the flag can be found. type: A data type of the new [`Flag`][enum_extensions.flags.Flag]. start: The initial value of the new flag (used by [`auto`][enum_extensions.auto.auto]). boundary: The [`FlagBoundary`][enum_extensions.flags.FlagBoundary] to use. [`None`] means it should be inherited. The default boundary in the end is [`STRICT`][enum_extensions.flags.FlagBoundary.STRICT]. **members: A `name -> value` mapping of [`Flag`][enum_extensions.flags.Flag] members. Raises: ValueError: The member was not found. ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] type or a member found. \"\"\" if names or module or qualified_name or type or start or boundary or members : return self . create ( value , names , module = module , qualified_name = qualified_name , type = type , start = start , boundary = boundary , direct_call = False , ** members , ) return self . __new__ ( self , value ) def create ( self : FT , flag_name : str , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , boundary : Optional [ FlagBoundary ] = None , direct_call : bool = True , ** members : Any , ) -> FT : \"\"\"Creates a new flag. Example: ```python Color = Flag(\"Color\", (\"RED\", \"GREEN\", \"BLUE\")) ``` Arguments: flag_name: The name of the new [`Flag`][enum_extensions.flags.Flag] to create. names: The names/values of the new flag members. module: The name of the module the [`Flag`][enum_extensions.flags.Flag] is created in. qualified_name: The actual location in the module where the flag can be found. type: A data type of the new [`Flag`][enum_extensions.flags.Flag]. start: The initial value of the new flag (used by [`auto`][enum_extensions.auto.auto]). boundary: The [`FlagBoundary`][enum_extensions.flags.FlagBoundary] to use. [`None`][None] means it should be inherited. The default boundary in the end is [`STRICT`][enum_extensions.flags.FlagBoundary.STRICT]. direct_call: Controls if the function is called directly or not. This argument should be used with caution. **members: A `name -> value` mapping of [`Flag`][enum_extensions.flags.Flag] members. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] type. \"\"\" meta = standard_type ( self ) bases = ( self ,) if type is None else ( type , self ) enum_type = find_enum_type ( bases ) namespace = meta . __prepare__ ( flag_name , bases , start = start , boundary = boundary ) if names is not None : # special processing needed for strings if is_string ( names ): names = names . replace ( COMMA , SPACE ) . strip () . split () if is_mapping ( names ): namespace . update ( names ) else : iterator = iter ( names ) item = next ( iterator , null ) if is_not_null ( item ): iterator = prepend ( item , iterator ) if is_string ( item ): original_names , names = names , [] values = [] for count , name in enumerate ( original_names ): value = enum_type . enum_generate_next_value ( name , start , count , values . copy () ) values . append ( value ) names . append (( name , value )) iterator = iter ( names ) namespace . update ( iterator ) namespace . update ( members ) # TODO: replace the frame hack if a blessed way to know the calling # module is ever developed if module is None : try : module = get_frame ( DIRECT_CALLER if direct_call else NESTED_CALLER ) . f_globals [ NAME ] except ( AttributeError , ValueError , KeyError ): # pragma: no cover pass if module is None : # pragma: no cover make_namespace_unpicklable ( namespace ) else : namespace [ MODULE ] = module if qualified_name is None : if module is not None : qualified_name = QUALIFIED_NAME_STRING . format ( module , flag_name ) if qualified_name is not None : namespace [ QUALIFIED_NAME ] = qualified_name return meta . __new__ ( meta , flag_name , bases , namespace , boundary = boundary ) def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name. Example: ```python >>> Permission <flag `Permission`> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return FLAG_REPRESENTATION . format ( tick ( get_name ( self ))) def _iter_member_by_value ( self : Type [ F ], value : int ) -> Iterator [ F ]: value_mapping = self . _value_mapping for value in iter_bits ( value & self . _flag_mask ): yield value_mapping [ value ] _iter_member = _iter_member_by_value def _iter_member_by_defintion ( self : Type [ F ], value : int ) -> Iterator [ F ]: return iter ( sorted ( self . _iter_member_by_value ( value ), key = lambda flag : flag . _sort_order , ) ) def _prepare_names ( self , value : int ) -> Tuple [ List [ str ], int ]: flag_mask = self . _flag_mask unknown = value & ~ flag_mask value &= flag_mask names = [ flag . __enum_name__ for flag in self . _iter_member ( value )] return names , unknown def enum_missing ( self : Type [ F ], value : int ) -> F : \"\"\"Handles *out-of-range* `value` according to given boundary. Arguments: value: The value to handle. Raises: ValueError: An invalid value was given. Returns: The matching flag member. See [`FlagBoundary`][enum_extensions.flags.FlagBoundary] for more information. \"\"\" if not is_int ( value ): raise ValueError ( INVALID_VALUE . format ( repr ( value ), tick ( get_name ( self )))) flag_mask = self . _flag_mask all_bits = self . _full_mask bit_length = self . _bit_length boundary = self . _boundary negative_value : Optional [ int ] = None if ( # must be in range not ~ all_bits <= value <= all_bits # must not include any skipped flags or value & ( all_bits ^ flag_mask ) ): if boundary is STRICT : bits = max ( value . bit_length (), bit_length ) raise ValueError ( INVALID_BITS . format ( hex ( value ), tick ( get_name ( self )), bin ( value , bits ), bin ( flag_mask , bits ) ) ) elif boundary is CONFORM : value &= flag_mask elif boundary is KEEP : if value < 0 : negative_value = value value = bit_at ( max ( bit_length , value . bit_length ())) + value else : # pragma: no cover raise ValueError ( UNKNOWN_BOUNDARY . format ( repr ( boundary ))) if value < 0 : negative_value = value value += bit_at ( bit_length ) unknown = value & ~ flag_mask if unknown and boundary is not KEEP : # pragma: no cover # TODO: cover? raise ValueError ( UNKNOWN_VALUES . format ( get_name ( self ), value , unknown , bin ( unknown ))) member = self . add_member ( None , value ) if negative_value is not None : self . _value_mapping [ negative_value ] = member return member def add_member ( self : Type [ F ], name : Optional [ str ], value : int ) -> F : \"\"\"Adds a new member to the [`Flag`][enum_extensions.flags.Flag]. Example: ```python class Permission(Flag): R = 4 W = 2 X = 1 permission = Permission.add_member(\"N\", 0) # <Perm.N: 0> ``` Arguments: name: The name of a member. value: The value of a member. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] member. \"\"\" member = super () . add_member ( name , value ) self . _modify_mask_and_iter () return member def from_values ( self : Type [ F ], * values : int , bound : bool = True ) -> F : \"\"\"Searches for flag members by values, combining them into a single composite member. Example: ```python >>> Permission.from_values(4, 2) <Permission.R|W: 6> ``` Arguments: *values: The values to look up. bound: Whether to ignore invalid values. Raises: ValueError: An invalid value was encountered and `bound` is false. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) if bound : for value in values : result |= self . from_value ( value ) else : for value in values : result |= self . from_value ( value , 0 ) return result def from_names ( self : Type [ F ], * names : str ) -> F : \"\"\"Searches for flag members by names, combining them into a single composite member. Example: ```python >>> Permission.from_names(\"r\", \"w\", \"x\") <Permission.R|W|X: 7> ``` Arguments: *names: The names to look up. Raises: KeyError: An invalid name was encountered. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) for name in names : result |= self . from_name ( name ) return result def from_multiple_data ( self : Type [ F ], * multiple_data : Union [ int , str ], bound : bool = True ) -> F : \"\"\"Searches for flag members by names or values, combining them into a single composite member. Example: ```python >>> Permission.from_multiple_data(0, \"x\") <Permission.X: 1> ``` Arguments: *multiple_data: The names and values to look up. bound: Whether to ignore invalid entries. Raises: ValueError: Invalid data was encountered and `bound` is false. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) if bound : for data in multiple_data : result |= self . from_data ( data ) else : for data in multiple_data : result |= self . from_data ( data , 0 ) return result","title":"FlagType"},{"location":"reference/flags/#enum_extensions.flags.FlagType.__call__","text":"Looks up an existing member or creates a new flag. Example Creation: Color = Flag ( \"Color\" , RED = 1 , GREEN = 2 , BLUE = 4 ) Value lookup: blue = Color ( 4 ) # <Color.BLUE: 4> Parameters: Name Type Description Default value Any The value to search for or the name of the new Flag to create. required names Optional [ Names ] The names/values of the new flag members. None module Optional [ str ] The name of the module the Flag is created in. None qualified_name Optional [ str ] The actual location in the module where the flag can be found. None type Optional [ AnyType ] A data type of the new Flag . None start Optional [ Any ] The initial value of the new flag (used by auto ). None boundary Optional [ FlagBoundary ] The FlagBoundary to use. [ None ] means it should be inherited. The default boundary in the end is STRICT . None **members Any A name -> value mapping of Flag members. {} Raises: Type Description ValueError The member was not found. ValueError The name is already used by another member. Returns: Type Description Union [ F , Type [ F ]] A newly created Flag type or a member found. Source code in enum_extensions/flags.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def __call__ ( self : Type [ F ], value : Any , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , boundary : Optional [ FlagBoundary ] = None , ** members : Any , ) -> Union [ F , Type [ F ]]: \"\"\"Looks up an existing member or creates a new flag. Example: Creation: ```python Color = Flag(\"Color\", RED=1, GREEN=2, BLUE=4) ``` Value lookup: ```python blue = Color(4) # <Color.BLUE: 4> ``` Arguments: value: The value to search for or the name of the new [`Flag`][enum_extensions.flags.Flag] to create. names: The names/values of the new flag members. module: The name of the module the [`Flag`][enum_extensions.flags.Flag] is created in. qualified_name: The actual location in the module where the flag can be found. type: A data type of the new [`Flag`][enum_extensions.flags.Flag]. start: The initial value of the new flag (used by [`auto`][enum_extensions.auto.auto]). boundary: The [`FlagBoundary`][enum_extensions.flags.FlagBoundary] to use. [`None`] means it should be inherited. The default boundary in the end is [`STRICT`][enum_extensions.flags.FlagBoundary.STRICT]. **members: A `name -> value` mapping of [`Flag`][enum_extensions.flags.Flag] members. Raises: ValueError: The member was not found. ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] type or a member found. \"\"\" if names or module or qualified_name or type or start or boundary or members : return self . create ( value , names , module = module , qualified_name = qualified_name , type = type , start = start , boundary = boundary , direct_call = False , ** members , ) return self . __new__ ( self , value )","title":"__call__()"},{"location":"reference/flags/#enum_extensions.flags.FlagType.create","text":"Creates a new flag. Example Color = Flag ( \"Color\" , ( \"RED\" , \"GREEN\" , \"BLUE\" )) Parameters: Name Type Description Default flag_name str The name of the new Flag to create. required names Optional [ Names ] The names/values of the new flag members. None module Optional [ str ] The name of the module the Flag is created in. None qualified_name Optional [ str ] The actual location in the module where the flag can be found. None type Optional [ AnyType ] A data type of the new Flag . None start Optional [ Any ] The initial value of the new flag (used by auto ). None boundary Optional [ FlagBoundary ] The FlagBoundary to use. None means it should be inherited. The default boundary in the end is STRICT . None direct_call bool Controls if the function is called directly or not. This argument should be used with caution. True **members Any A name -> value mapping of Flag members. {} Raises: Type Description ValueError The name is already used by another member. Returns: Type Description FT A newly created Flag type. Source code in enum_extensions/flags.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def create ( self : FT , flag_name : str , names : Optional [ Names ] = None , * , module : Optional [ str ] = None , qualified_name : Optional [ str ] = None , type : Optional [ AnyType ] = None , start : Optional [ Any ] = None , boundary : Optional [ FlagBoundary ] = None , direct_call : bool = True , ** members : Any , ) -> FT : \"\"\"Creates a new flag. Example: ```python Color = Flag(\"Color\", (\"RED\", \"GREEN\", \"BLUE\")) ``` Arguments: flag_name: The name of the new [`Flag`][enum_extensions.flags.Flag] to create. names: The names/values of the new flag members. module: The name of the module the [`Flag`][enum_extensions.flags.Flag] is created in. qualified_name: The actual location in the module where the flag can be found. type: A data type of the new [`Flag`][enum_extensions.flags.Flag]. start: The initial value of the new flag (used by [`auto`][enum_extensions.auto.auto]). boundary: The [`FlagBoundary`][enum_extensions.flags.FlagBoundary] to use. [`None`][None] means it should be inherited. The default boundary in the end is [`STRICT`][enum_extensions.flags.FlagBoundary.STRICT]. direct_call: Controls if the function is called directly or not. This argument should be used with caution. **members: A `name -> value` mapping of [`Flag`][enum_extensions.flags.Flag] members. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] type. \"\"\" meta = standard_type ( self ) bases = ( self ,) if type is None else ( type , self ) enum_type = find_enum_type ( bases ) namespace = meta . __prepare__ ( flag_name , bases , start = start , boundary = boundary ) if names is not None : # special processing needed for strings if is_string ( names ): names = names . replace ( COMMA , SPACE ) . strip () . split () if is_mapping ( names ): namespace . update ( names ) else : iterator = iter ( names ) item = next ( iterator , null ) if is_not_null ( item ): iterator = prepend ( item , iterator ) if is_string ( item ): original_names , names = names , [] values = [] for count , name in enumerate ( original_names ): value = enum_type . enum_generate_next_value ( name , start , count , values . copy () ) values . append ( value ) names . append (( name , value )) iterator = iter ( names ) namespace . update ( iterator ) namespace . update ( members ) # TODO: replace the frame hack if a blessed way to know the calling # module is ever developed if module is None : try : module = get_frame ( DIRECT_CALLER if direct_call else NESTED_CALLER ) . f_globals [ NAME ] except ( AttributeError , ValueError , KeyError ): # pragma: no cover pass if module is None : # pragma: no cover make_namespace_unpicklable ( namespace ) else : namespace [ MODULE ] = module if qualified_name is None : if module is not None : qualified_name = QUALIFIED_NAME_STRING . format ( module , flag_name ) if qualified_name is not None : namespace [ QUALIFIED_NAME ] = qualified_name return meta . __new__ ( meta , flag_name , bases , namespace , boundary = boundary )","title":"create()"},{"location":"reference/flags/#enum_extensions.flags.FlagType.__repr__","text":"Returns the string used by repr calls. By default contains the Flag name. Example >>> Permission < flag ` Permission ` > Returns: Type Description str The string used in the repr function. Source code in enum_extensions/flags.py 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name. Example: ```python >>> Permission <flag `Permission`> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return FLAG_REPRESENTATION . format ( tick ( get_name ( self )))","title":"__repr__()"},{"location":"reference/flags/#enum_extensions.flags.FlagType.enum_missing","text":"Handles out-of-range value according to given boundary. Parameters: Name Type Description Default value int The value to handle. required Raises: Type Description ValueError An invalid value was given. Returns: Type Description F The matching flag member. See FlagBoundary F for more information. Source code in enum_extensions/flags.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def enum_missing ( self : Type [ F ], value : int ) -> F : \"\"\"Handles *out-of-range* `value` according to given boundary. Arguments: value: The value to handle. Raises: ValueError: An invalid value was given. Returns: The matching flag member. See [`FlagBoundary`][enum_extensions.flags.FlagBoundary] for more information. \"\"\" if not is_int ( value ): raise ValueError ( INVALID_VALUE . format ( repr ( value ), tick ( get_name ( self )))) flag_mask = self . _flag_mask all_bits = self . _full_mask bit_length = self . _bit_length boundary = self . _boundary negative_value : Optional [ int ] = None if ( # must be in range not ~ all_bits <= value <= all_bits # must not include any skipped flags or value & ( all_bits ^ flag_mask ) ): if boundary is STRICT : bits = max ( value . bit_length (), bit_length ) raise ValueError ( INVALID_BITS . format ( hex ( value ), tick ( get_name ( self )), bin ( value , bits ), bin ( flag_mask , bits ) ) ) elif boundary is CONFORM : value &= flag_mask elif boundary is KEEP : if value < 0 : negative_value = value value = bit_at ( max ( bit_length , value . bit_length ())) + value else : # pragma: no cover raise ValueError ( UNKNOWN_BOUNDARY . format ( repr ( boundary ))) if value < 0 : negative_value = value value += bit_at ( bit_length ) unknown = value & ~ flag_mask if unknown and boundary is not KEEP : # pragma: no cover # TODO: cover? raise ValueError ( UNKNOWN_VALUES . format ( get_name ( self ), value , unknown , bin ( unknown ))) member = self . add_member ( None , value ) if negative_value is not None : self . _value_mapping [ negative_value ] = member return member","title":"enum_missing()"},{"location":"reference/flags/#enum_extensions.flags.FlagType.add_member","text":"Adds a new member to the Flag . Example class Permission ( Flag ): R = 4 W = 2 X = 1 permission = Permission . add_member ( \"N\" , 0 ) # <Perm.N: 0> Parameters: Name Type Description Default name Optional [ str ] The name of a member. required value int The value of a member. required Raises: Type Description ValueError The name is already used by another member. Returns: Type Description F A newly created Flag member. Source code in enum_extensions/flags.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 def add_member ( self : Type [ F ], name : Optional [ str ], value : int ) -> F : \"\"\"Adds a new member to the [`Flag`][enum_extensions.flags.Flag]. Example: ```python class Permission(Flag): R = 4 W = 2 X = 1 permission = Permission.add_member(\"N\", 0) # <Perm.N: 0> ``` Arguments: name: The name of a member. value: The value of a member. Raises: ValueError: The name is already used by another member. Returns: A newly created [`Flag`][enum_extensions.flags.Flag] member. \"\"\" member = super () . add_member ( name , value ) self . _modify_mask_and_iter () return member","title":"add_member()"},{"location":"reference/flags/#enum_extensions.flags.FlagType.from_values","text":"Searches for flag members by values, combining them into a single composite member. Example >>> Permission . from_values ( 4 , 2 ) < Permission . R | W : 6 > Parameters: Name Type Description Default *values int The values to look up. () bound bool Whether to ignore invalid values. True Raises: Type Description ValueError An invalid value was encountered and bound is false. Returns: Type Description F The combined Flag member. Source code in enum_extensions/flags.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 def from_values ( self : Type [ F ], * values : int , bound : bool = True ) -> F : \"\"\"Searches for flag members by values, combining them into a single composite member. Example: ```python >>> Permission.from_values(4, 2) <Permission.R|W: 6> ``` Arguments: *values: The values to look up. bound: Whether to ignore invalid values. Raises: ValueError: An invalid value was encountered and `bound` is false. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) if bound : for value in values : result |= self . from_value ( value ) else : for value in values : result |= self . from_value ( value , 0 ) return result","title":"from_values()"},{"location":"reference/flags/#enum_extensions.flags.FlagType.from_names","text":"Searches for flag members by names, combining them into a single composite member. Example >>> Permission . from_names ( \"r\" , \"w\" , \"x\" ) < Permission . R | W | X : 7 > Parameters: Name Type Description Default *names str The names to look up. () Raises: Type Description KeyError An invalid name was encountered. Returns: Type Description F The combined Flag member. Source code in enum_extensions/flags.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 def from_names ( self : Type [ F ], * names : str ) -> F : \"\"\"Searches for flag members by names, combining them into a single composite member. Example: ```python >>> Permission.from_names(\"r\", \"w\", \"x\") <Permission.R|W|X: 7> ``` Arguments: *names: The names to look up. Raises: KeyError: An invalid name was encountered. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) for name in names : result |= self . from_name ( name ) return result","title":"from_names()"},{"location":"reference/flags/#enum_extensions.flags.FlagType.from_multiple_data","text":"Searches for flag members by names or values, combining them into a single composite member. Example >>> Permission . from_multiple_data ( 0 , \"x\" ) < Permission . X : 1 > Parameters: Name Type Description Default *multiple_data Union [ int , str ] The names and values to look up. () bound bool Whether to ignore invalid entries. True Raises: Type Description ValueError Invalid data was encountered and bound is false. Returns: Type Description F The combined Flag member. Source code in enum_extensions/flags.py 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 def from_multiple_data ( self : Type [ F ], * multiple_data : Union [ int , str ], bound : bool = True ) -> F : \"\"\"Searches for flag members by names or values, combining them into a single composite member. Example: ```python >>> Permission.from_multiple_data(0, \"x\") <Permission.X: 1> ``` Arguments: *multiple_data: The names and values to look up. bound: Whether to ignore invalid entries. Raises: ValueError: Invalid data was encountered and `bound` is false. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" result = self ( 0 ) if bound : for data in multiple_data : result |= self . from_data ( data ) else : for data in multiple_data : result |= self . from_data ( data , 0 ) return result","title":"from_multiple_data()"},{"location":"reference/flags/#enum_extensions.flags.Flag","text":"Bases: Enum Support for bit flags. Source code in enum_extensions/flags.py 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 class Flag ( Enum , metaclass = FlagType ): \"\"\"Support for bit flags.\"\"\" __enum_value__ : int def __iter__ ( self : FlagT ) -> Iterator [ FlagT ]: \"\"\"Returns an iterator over invididual (single-bit) flag members. Example: ```python >>> tuple(Permission.R | Permission.W) (<Permission.R: 4>, <Permission.W: 2>) ``` Returns: An iterator over single-bit [`Flag`][enum_extensions.flags.Flag] members. \"\"\" return type ( self ) . _iter_member ( self . __enum_value__ ) def __contains__ ( self : FlagT , flag : FlagT ) -> bool : \"\"\"Checks whether the `flag` is in [`Flag`][enum_extensions.flags.Flag]. Example: ```python >>> rw = Permission.R | Permission.W >>> x = Permission.X >>> assert x not in rw ``` Arguments: flag: The flag member to check. Raises: TypeError: `flag` is not an instance of [`Flag`][enum_extensions.flags.Flag]. Returns: Whether the `flag` is contained in [`Flag`][enum_extensions.flags.Flag]. \"\"\" if not is_flag_member ( flag ): raise TypeError ( UNSUPPORTED_IN . format ( tick ( get_name ( type ( flag ))), tick ( get_name ( type ( self )))) ) self_value = self . __enum_value__ flag_value = flag . __enum_value__ if not self_value or not flag_value : return False return is_same_type ( flag , self ) and flag_value & self_value == flag_value def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name along with the (composite) member name and value. Example: ```python >>> Permission.R | Permission.W | Permission.X <Permission.R|W|X: 7> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return FLAG_MEMBER_REPRESENTATION . format ( get_name ( type ( self )), self . __enum_composite_name__ , self . __enum_value__ ) def __str__ ( self ) -> str : \"\"\"Returns the string used by [`str`][str] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name along with the (composite) member name. Example: ```python >>> print(Permission.R | Permission.X) Permission.R|X ``` Returns: The string used in the [`str`][str] function. \"\"\" return FLAG_MEMBER_STRING . format ( get_name ( type ( self )), self . __enum_composite_name__ ) def __len__ ( self ) -> int : \"\"\"Returns the number of bits in the member value. Example: ```python >>> len(Permission.N) 0 >>> len(Permission.R | Permission.W | Permission.X) 3 ``` Returns: The bit count of the member value. \"\"\" return bit_count ( self . __enum_value__ ) def __bool__ ( self ) -> bool : \"\"\"Checks whether the value is non-zero. Returns: Whether the value is non-zero. \"\"\" return bool ( self . __enum_value__ ) def __or__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `|` (*OR*) operation. Example: ```python >>> Permission.R | Permission.X <Permission.R|X: 5> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ | other . __enum_value__ ) return NotImplemented def __and__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `&` (*AND*) operation. Example: ```python >>> Permission.X & (Permission.R | Permission.W) <Permission.N: 0> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ & other . __enum_value__ ) return NotImplemented def __xor__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `^` (*XOR*) operation. Example: ```python >>> (Permission.R | Permission.X) ^ (Permission.W | Permission.X) <Permission.R|W: 6> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ ^ other . __enum_value__ ) return NotImplemented def __invert__ ( self : FlagT ) -> FlagT : \"\"\"Inverts (`~`) the [`Flag`][enum_extensions.flags.Flag] member value. Example: ```python >>> ~Permission.N <Permission.R|W|X: 7> ``` Returns: The inverted [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if self . _boundary is KEEP : return type ( self )( ~ self . __enum_value__ ) return type ( self )( self . __enum_value__ ^ self . _flag_mask ) __ior__ = __or__ __iand__ = __and__ __ixor__ = __xor__ __ror__ = __or__ __rand__ = __and__ __rxor__ = __xor__ enum_generate_next_value = staticmethod ( strict_bit_next_value ) @dynamic_attribute def __enum_composite_name__ ( self ) -> str : name = self . __enum_name__ if name is None : value = self . __enum_value__ if not value : return str ( value ) names , unknown = type ( self ) . _prepare_names ( value ) if not names : return hex ( unknown ) if unknown : names . append ( hex ( unknown )) return concat_pipe ( names ) return name @dynamic_attribute def __enum_composite_title_name__ ( self ) -> str : name = self . __enum_name__ if name is None : value = self . __enum_value__ if not value : return str ( value ) names , unknown = type ( self ) . _prepare_names ( value ) if not names : return hex ( unknown ) title = concat_comma_space ( map ( create_title , names )) if unknown : return title + SPACE + NOT_COVERED . format ( hex ( unknown )) return title return create_title ( name ) @dynamic_attribute def name ( self ) -> str : \"\"\"The name of the [`Flag`][enum_extensions.flags.Flag] member.\"\"\" return self . __enum_composite_name__ @dynamic_attribute def title_name ( self ) -> str : \"\"\"The human-readable name of the [`Flag`][enum_extensions.flags.Flag] member.\"\"\" return self . __enum_composite_title_name__","title":"Flag"},{"location":"reference/flags/#enum_extensions.flags.Flag.__iter__","text":"Returns an iterator over invididual (single-bit) flag members. Example >>> tuple ( Permission . R | Permission . W ) ( < Permission . R : 4 > , < Permission . W : 2 > ) Returns: Type Description Iterator [ FlagT ] An iterator over single-bit Flag members. Source code in enum_extensions/flags.py 681 682 683 684 685 686 687 688 689 690 691 692 693 def __iter__ ( self : FlagT ) -> Iterator [ FlagT ]: \"\"\"Returns an iterator over invididual (single-bit) flag members. Example: ```python >>> tuple(Permission.R | Permission.W) (<Permission.R: 4>, <Permission.W: 2>) ``` Returns: An iterator over single-bit [`Flag`][enum_extensions.flags.Flag] members. \"\"\" return type ( self ) . _iter_member ( self . __enum_value__ )","title":"__iter__()"},{"location":"reference/flags/#enum_extensions.flags.Flag.__contains__","text":"Checks whether the flag is in Flag . Example >>> rw = Permission . R | Permission . W >>> x = Permission . X >>> assert x not in rw Parameters: Name Type Description Default flag FlagT The flag member to check. required Raises: Type Description TypeError flag is not an instance of Flag . Returns: Type Description bool Whether the flag is contained in Flag . Source code in enum_extensions/flags.py 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 def __contains__ ( self : FlagT , flag : FlagT ) -> bool : \"\"\"Checks whether the `flag` is in [`Flag`][enum_extensions.flags.Flag]. Example: ```python >>> rw = Permission.R | Permission.W >>> x = Permission.X >>> assert x not in rw ``` Arguments: flag: The flag member to check. Raises: TypeError: `flag` is not an instance of [`Flag`][enum_extensions.flags.Flag]. Returns: Whether the `flag` is contained in [`Flag`][enum_extensions.flags.Flag]. \"\"\" if not is_flag_member ( flag ): raise TypeError ( UNSUPPORTED_IN . format ( tick ( get_name ( type ( flag ))), tick ( get_name ( type ( self )))) ) self_value = self . __enum_value__ flag_value = flag . __enum_value__ if not self_value or not flag_value : return False return is_same_type ( flag , self ) and flag_value & self_value == flag_value","title":"__contains__()"},{"location":"reference/flags/#enum_extensions.flags.Flag.__repr__","text":"Returns the string used by repr calls. By default contains the Flag name along with the (composite) member name and value. Example >>> Permission . R | Permission . W | Permission . X < Permission . R | W | X : 7 > Returns: Type Description str The string used in the repr function. Source code in enum_extensions/flags.py 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 def __repr__ ( self ) -> str : \"\"\"Returns the string used by [`repr`][repr] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name along with the (composite) member name and value. Example: ```python >>> Permission.R | Permission.W | Permission.X <Permission.R|W|X: 7> ``` Returns: The string used in the [`repr`][repr] function. \"\"\" return FLAG_MEMBER_REPRESENTATION . format ( get_name ( type ( self )), self . __enum_composite_name__ , self . __enum_value__ )","title":"__repr__()"},{"location":"reference/flags/#enum_extensions.flags.Flag.__str__","text":"Returns the string used by str calls. By default contains the Flag name along with the (composite) member name. Example >>> print ( Permission . R | Permission . X ) Permission . R | X Returns: Type Description str The string used in the str function. Source code in enum_extensions/flags.py 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 def __str__ ( self ) -> str : \"\"\"Returns the string used by [`str`][str] calls. By default contains the [`Flag`][enum_extensions.flags.Flag] name along with the (composite) member name. Example: ```python >>> print(Permission.R | Permission.X) Permission.R|X ``` Returns: The string used in the [`str`][str] function. \"\"\" return FLAG_MEMBER_STRING . format ( get_name ( type ( self )), self . __enum_composite_name__ )","title":"__str__()"},{"location":"reference/flags/#enum_extensions.flags.Flag.__len__","text":"Returns the number of bits in the member value. Example >>> len ( Permission . N ) 0 >>> len ( Permission . R | Permission . W | Permission . X ) 3 Returns: Type Description int The bit count of the member value. Source code in enum_extensions/flags.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 def __len__ ( self ) -> int : \"\"\"Returns the number of bits in the member value. Example: ```python >>> len(Permission.N) 0 >>> len(Permission.R | Permission.W | Permission.X) 3 ``` Returns: The bit count of the member value. \"\"\" return bit_count ( self . __enum_value__ )","title":"__len__()"},{"location":"reference/flags/#enum_extensions.flags.Flag.__bool__","text":"Checks whether the value is non-zero. Returns: Type Description bool Whether the value is non-zero. Source code in enum_extensions/flags.py 780 781 782 783 784 785 786 def __bool__ ( self ) -> bool : \"\"\"Checks whether the value is non-zero. Returns: Whether the value is non-zero. \"\"\" return bool ( self . __enum_value__ )","title":"__bool__()"},{"location":"reference/flags/#enum_extensions.flags.Flag.__or__","text":"Combines values of flag members via the | ( OR ) operation. Example >>> Permission . R | Permission . X < Permission . R | X : 5 > Parameters: Name Type Description Default other FlagT The flag member to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 def __or__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `|` (*OR*) operation. Example: ```python >>> Permission.R | Permission.X <Permission.R|X: 5> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ | other . __enum_value__ ) return NotImplemented","title":"__or__()"},{"location":"reference/flags/#enum_extensions.flags.Flag.__and__","text":"Combines values of flag members via the & ( AND ) operation. Example >>> Permission . X & ( Permission . R | Permission . W ) < Permission . N : 0 > Parameters: Name Type Description Default other FlagT The flag member to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 def __and__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `&` (*AND*) operation. Example: ```python >>> Permission.X & (Permission.R | Permission.W) <Permission.N: 0> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ & other . __enum_value__ ) return NotImplemented","title":"__and__()"},{"location":"reference/flags/#enum_extensions.flags.Flag.__xor__","text":"Combines values of flag members via the ^ ( XOR ) operation. Example >>> ( Permission . R | Permission . X ) ^ ( Permission . W | Permission . X ) < Permission . R | W : 6 > Parameters: Name Type Description Default other FlagT The flag member to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 def __xor__ ( self : FlagT , other : FlagT ) -> FlagT : \"\"\"Combines values of flag members via the `^` (*XOR*) operation. Example: ```python >>> (Permission.R | Permission.X) ^ (Permission.W | Permission.X) <Permission.R|W: 6> ``` Arguments: other: The flag member to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_same_type ( other , self ): return type ( self )( self . __enum_value__ ^ other . __enum_value__ ) return NotImplemented","title":"__xor__()"},{"location":"reference/flags/#enum_extensions.flags.Flag.__invert__","text":"Inverts ( ~ ) the Flag member value. Example >>> ~ Permission . N < Permission . R | W | X : 7 > Returns: Type Description FlagT The inverted Flag member. Source code in enum_extensions/flags.py 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 def __invert__ ( self : FlagT ) -> FlagT : \"\"\"Inverts (`~`) the [`Flag`][enum_extensions.flags.Flag] member value. Example: ```python >>> ~Permission.N <Permission.R|W|X: 7> ``` Returns: The inverted [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if self . _boundary is KEEP : return type ( self )( ~ self . __enum_value__ ) return type ( self )( self . __enum_value__ ^ self . _flag_mask )","title":"__invert__()"},{"location":"reference/flags/#enum_extensions.flags.Flag.name","text":"The name of the Flag member. Source code in enum_extensions/flags.py 924 925 926 927 928 @dynamic_attribute def name ( self ) -> str : \"\"\"The name of the [`Flag`][enum_extensions.flags.Flag] member.\"\"\" return self . __enum_composite_name__","title":"name()"},{"location":"reference/flags/#enum_extensions.flags.Flag.title_name","text":"The human-readable name of the Flag member. Source code in enum_extensions/flags.py 930 931 932 933 934 @dynamic_attribute def title_name ( self ) -> str : \"\"\"The human-readable name of the [`Flag`][enum_extensions.flags.Flag] member.\"\"\" return self . __enum_composite_title_name__","title":"title_name()"},{"location":"reference/flags/#enum_extensions.flags.IntFlag","text":"Bases: int , Flag Support for integer-like bit flags. Source code in enum_extensions/flags.py 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 class IntFlag ( int , Flag , boundary = KEEP ): \"\"\"Support for integer-like bit flags.\"\"\" def __contains__ ( self : FlagT , other : Union [ int , FlagT ]) -> bool : \"\"\"Checks whether `other` is in [`Flag`][enum_extensions.flags.Flag]. Example: ```python IntPermission = IntFlag(\"IntPermission\", R=4, W=2, X=1, N=0) r, w, x, n = IntPermission rx = r | x assert r in rx assert not w in rx assert x.value in rx ``` Arguments: other: The flag member or value to check. Raises: TypeError: `other` is not an [`int`][int] or a [`Flag`][enum_extensions.flags.Flag] member. Returns: Whether `other` is contained in [`Flag`][enum_extensions.flags.Flag]. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __contains__ ( other ) def __or__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `|` (*OR*) operation. Example: ```python >>> IntPermission.R | 2 <IntPermission.R|W: 6> >>> IntPermission.W | IntPermission.X <IntPermission.W|X: 2> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __or__ ( other ) def __and__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `&` (*AND*) operation. Example: ```python >>> IntPermission.W & (IntPermission.R | IntPermission.X) <IntPermission.N: 0> >>> IntPermission.X & 1 <IntPermission.X: 1> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __and__ ( other ) def __xor__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `^` (*XOR*) operation. Example: ```python >>> (IntPermission.W | IntPermission.X) ^ (IntPermission.R | IntPermission.X) <IntPermission.R|W: 6> >>> IntPermission.X ^ 1 <IntPermission.N: 0> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __xor__ ( other ) __ior__ = __or__ __iand__ = __and__ __ixor__ = __xor__ __ror__ = __or__ __rand__ = __and__ __rxor__ = __xor__","title":"IntFlag"},{"location":"reference/flags/#enum_extensions.flags.IntFlag.__contains__","text":"Checks whether other is in Flag . Example IntPermission = IntFlag ( \"IntPermission\" , R = 4 , W = 2 , X = 1 , N = 0 ) r , w , x , n = IntPermission rx = r | x assert r in rx assert not w in rx assert x . value in rx Parameters: Name Type Description Default other Union [ int , FlagT ] The flag member or value to check. required Raises: Type Description TypeError other is not an int or a Flag member. Returns: Type Description bool Whether other is contained in Flag . Source code in enum_extensions/flags.py 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 def __contains__ ( self : FlagT , other : Union [ int , FlagT ]) -> bool : \"\"\"Checks whether `other` is in [`Flag`][enum_extensions.flags.Flag]. Example: ```python IntPermission = IntFlag(\"IntPermission\", R=4, W=2, X=1, N=0) r, w, x, n = IntPermission rx = r | x assert r in rx assert not w in rx assert x.value in rx ``` Arguments: other: The flag member or value to check. Raises: TypeError: `other` is not an [`int`][int] or a [`Flag`][enum_extensions.flags.Flag] member. Returns: Whether `other` is contained in [`Flag`][enum_extensions.flags.Flag]. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __contains__ ( other )","title":"__contains__()"},{"location":"reference/flags/#enum_extensions.flags.IntFlag.__or__","text":"Combines values (of flag members) via the | ( OR ) operation. Example >>> IntPermission . R | 2 < IntPermission . R | W : 6 > >>> IntPermission . W | IntPermission . X < IntPermission . W | X : 2 > Parameters: Name Type Description Default other Union [ int , FlagT ] The flag member or value to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 def __or__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `|` (*OR*) operation. Example: ```python >>> IntPermission.R | 2 <IntPermission.R|W: 6> >>> IntPermission.W | IntPermission.X <IntPermission.W|X: 2> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __or__ ( other )","title":"__or__()"},{"location":"reference/flags/#enum_extensions.flags.IntFlag.__and__","text":"Combines values (of flag members) via the & ( AND ) operation. Example >>> IntPermission . W & ( IntPermission . R | IntPermission . X ) < IntPermission . N : 0 > >>> IntPermission . X & 1 < IntPermission . X : 1 > Parameters: Name Type Description Default other Union [ int , FlagT ] The flag member or value to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 def __and__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `&` (*AND*) operation. Example: ```python >>> IntPermission.W & (IntPermission.R | IntPermission.X) <IntPermission.N: 0> >>> IntPermission.X & 1 <IntPermission.X: 1> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __and__ ( other )","title":"__and__()"},{"location":"reference/flags/#enum_extensions.flags.IntFlag.__xor__","text":"Combines values (of flag members) via the ^ ( XOR ) operation. Example >>> ( IntPermission . W | IntPermission . X ) ^ ( IntPermission . R | IntPermission . X ) < IntPermission . R | W : 6 > >>> IntPermission . X ^ 1 < IntPermission . N : 0 > Parameters: Name Type Description Default other Union [ int , FlagT ] The flag member or value to combine self with. required Returns: Type Description FlagT The combined Flag member. Source code in enum_extensions/flags.py 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def __xor__ ( self : FlagT , other : Union [ int , FlagT ]) -> FlagT : \"\"\"Combines values (of flag members) via the `^` (*XOR*) operation. Example: ```python >>> (IntPermission.W | IntPermission.X) ^ (IntPermission.R | IntPermission.X) <IntPermission.R|W: 6> >>> IntPermission.X ^ 1 <IntPermission.N: 0> ``` Arguments: other: The flag member or value to combine `self` with. Returns: The combined [`Flag`][enum_extensions.flags.Flag] member. \"\"\" if is_int ( other ): other = type ( self )( other ) return super () . __xor__ ( other )","title":"__xor__()"},{"location":"reference/members/","text":"Member Bases: Generic [ T ] Forces an item to become an Enum member. Source code in enum_extensions/members.py 12 13 14 15 16 17 18 19 20 21 class Member ( Generic [ T ]): \"\"\"Forces an item to become an [`Enum`][enum_extensions.enums.Enum] member.\"\"\" def __init__ ( self , value : T ) -> None : self . _value = value @property def value ( self ) -> T : \"\"\"The wrapped value to enforce enumeration membership of.\"\"\" return self . _value value () property The wrapped value to enforce enumeration membership of. Source code in enum_extensions/members.py 18 19 20 21 @property def value ( self ) -> T : \"\"\"The wrapped value to enforce enumeration membership of.\"\"\" return self . _value NonMember Bases: Generic [ T ] Protects an item from becoming an Enum member. Source code in enum_extensions/members.py 24 25 26 27 28 29 30 31 32 33 class NonMember ( Generic [ T ]): \"\"\"Protects an item from becoming an [`Enum`][enum_extensions.enums.Enum] member.\"\"\" def __init__ ( self , value : T ) -> None : self . _value = value @property def value ( self ) -> T : \"\"\"The wrapped value to protect from becoming a member.\"\"\" return self . _value value () property The wrapped value to protect from becoming a member. Source code in enum_extensions/members.py 30 31 32 33 @property def value ( self ) -> T : \"\"\"The wrapped value to protect from becoming a member.\"\"\" return self . _value member ( value ) Forces an item to become an Enum member. This is the same as Member(value) . Example def increment ( value : int ) -> int : return value + 1 class Function ( Enum ): INCREMENT = member ( increment ) function = Function . INCREMENT # <Function.INCREMENT: <function increment at ...>> Parameters: Name Type Description Default value R The value to enforce enumeration membership of. required Returns: Type Description Member [ R ] An instance of Member with the value wrapped. Source code in enum_extensions/members.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def member ( value : R ) -> Member [ R ]: \"\"\"Forces an item to become an [`Enum`][enum_extensions.enums.Enum] member. This is the same as `Member(value)`. Example: ```python def increment(value: int) -> int: return value + 1 class Function(Enum): INCREMENT = member(increment) function = Function.INCREMENT # <Function.INCREMENT: <function increment at ...>> ``` Arguments: value: The value to enforce enumeration membership of. Returns: An instance of [`Member`][enum_extensions.members.Member] with the `value` wrapped. \"\"\" return Member ( value ) non_member ( value ) Protects an item from becoming an Enum member. This is the same as NonMember(value) . Example class Test : TEST = non_member ( 42 ) test = Test . TEST # 42 Parameters: Name Type Description Default value R The value to protect from becoming a member. required Returns: Type Description NonMember [ R ] An instance of NonMember with the value wrapped. Source code in enum_extensions/members.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def non_member ( value : R ) -> NonMember [ R ]: \"\"\"Protects an item from becoming an [`Enum`][enum_extensions.enums.Enum] member. This is the same as `NonMember(value)`. Example: ```python class Test: TEST = non_member(42) test = Test.TEST # 42 ``` Arguments: value: The value to protect from becoming a member. Returns: An instance of [`NonMember`][enum_extensions.members.NonMember] with the `value` wrapped. \"\"\" return NonMember ( value ) is_member ( item ) Checks if an item is an instance of Member . Example assert is_member ( member ( 13 )) assert not is_member ( 13 ) Parameters: Name Type Description Default item MaybeMember [ T ] An instance to check. required Returns: Type Description TypeGuard [ Member [ T ]] Whether an item is an instance of Member . Source code in enum_extensions/members.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def is_member ( item : MaybeMember [ T ]) -> TypeGuard [ Member [ T ]]: \"\"\"Checks if an `item` is an instance of [`Member`][enum_extensions.members.Member]. Example: ```python assert is_member(member(13)) assert not is_member(13) ``` Arguments: item: An instance to check. Returns: Whether an item is an instance of [`Member`][enum_extensions.members.Member]. \"\"\" return is_instance ( item , Member ) is_non_member ( item ) Checks if an item is an instance of NonMember . Example assert is_non_member ( non_member ( 25 )) assert not is_non_member ( 25 ) Parameters: Name Type Description Default item MaybeNonMember [ T ] An instance to check. required Returns: Type Description TypeGuard [ NonMember [ T ]] Whether an item is an instance of NonMember . Source code in enum_extensions/members.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def is_non_member ( item : MaybeNonMember [ T ]) -> TypeGuard [ NonMember [ T ]]: \"\"\"Checks if an `item` is an instance of [`NonMember`][enum_extensions.members.NonMember]. Example: ```python assert is_non_member(non_member(25)) assert not is_non_member(25) ``` Arguments: item: An instance to check. Returns: Whether an item is an instance of [`NonMember`][enum_extensions.members.NonMember]. \"\"\" return is_instance ( item , NonMember )","title":"Members"},{"location":"reference/members/#enum_extensions.members.Member","text":"Bases: Generic [ T ] Forces an item to become an Enum member. Source code in enum_extensions/members.py 12 13 14 15 16 17 18 19 20 21 class Member ( Generic [ T ]): \"\"\"Forces an item to become an [`Enum`][enum_extensions.enums.Enum] member.\"\"\" def __init__ ( self , value : T ) -> None : self . _value = value @property def value ( self ) -> T : \"\"\"The wrapped value to enforce enumeration membership of.\"\"\" return self . _value","title":"Member"},{"location":"reference/members/#enum_extensions.members.Member.value","text":"The wrapped value to enforce enumeration membership of. Source code in enum_extensions/members.py 18 19 20 21 @property def value ( self ) -> T : \"\"\"The wrapped value to enforce enumeration membership of.\"\"\" return self . _value","title":"value()"},{"location":"reference/members/#enum_extensions.members.NonMember","text":"Bases: Generic [ T ] Protects an item from becoming an Enum member. Source code in enum_extensions/members.py 24 25 26 27 28 29 30 31 32 33 class NonMember ( Generic [ T ]): \"\"\"Protects an item from becoming an [`Enum`][enum_extensions.enums.Enum] member.\"\"\" def __init__ ( self , value : T ) -> None : self . _value = value @property def value ( self ) -> T : \"\"\"The wrapped value to protect from becoming a member.\"\"\" return self . _value","title":"NonMember"},{"location":"reference/members/#enum_extensions.members.NonMember.value","text":"The wrapped value to protect from becoming a member. Source code in enum_extensions/members.py 30 31 32 33 @property def value ( self ) -> T : \"\"\"The wrapped value to protect from becoming a member.\"\"\" return self . _value","title":"value()"},{"location":"reference/members/#enum_extensions.members.member","text":"Forces an item to become an Enum member. This is the same as Member(value) . Example def increment ( value : int ) -> int : return value + 1 class Function ( Enum ): INCREMENT = member ( increment ) function = Function . INCREMENT # <Function.INCREMENT: <function increment at ...>> Parameters: Name Type Description Default value R The value to enforce enumeration membership of. required Returns: Type Description Member [ R ] An instance of Member with the value wrapped. Source code in enum_extensions/members.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def member ( value : R ) -> Member [ R ]: \"\"\"Forces an item to become an [`Enum`][enum_extensions.enums.Enum] member. This is the same as `Member(value)`. Example: ```python def increment(value: int) -> int: return value + 1 class Function(Enum): INCREMENT = member(increment) function = Function.INCREMENT # <Function.INCREMENT: <function increment at ...>> ``` Arguments: value: The value to enforce enumeration membership of. Returns: An instance of [`Member`][enum_extensions.members.Member] with the `value` wrapped. \"\"\" return Member ( value )","title":"member()"},{"location":"reference/members/#enum_extensions.members.non_member","text":"Protects an item from becoming an Enum member. This is the same as NonMember(value) . Example class Test : TEST = non_member ( 42 ) test = Test . TEST # 42 Parameters: Name Type Description Default value R The value to protect from becoming a member. required Returns: Type Description NonMember [ R ] An instance of NonMember with the value wrapped. Source code in enum_extensions/members.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def non_member ( value : R ) -> NonMember [ R ]: \"\"\"Protects an item from becoming an [`Enum`][enum_extensions.enums.Enum] member. This is the same as `NonMember(value)`. Example: ```python class Test: TEST = non_member(42) test = Test.TEST # 42 ``` Arguments: value: The value to protect from becoming a member. Returns: An instance of [`NonMember`][enum_extensions.members.NonMember] with the `value` wrapped. \"\"\" return NonMember ( value )","title":"non_member()"},{"location":"reference/members/#enum_extensions.members.is_member","text":"Checks if an item is an instance of Member . Example assert is_member ( member ( 13 )) assert not is_member ( 13 ) Parameters: Name Type Description Default item MaybeMember [ T ] An instance to check. required Returns: Type Description TypeGuard [ Member [ T ]] Whether an item is an instance of Member . Source code in enum_extensions/members.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def is_member ( item : MaybeMember [ T ]) -> TypeGuard [ Member [ T ]]: \"\"\"Checks if an `item` is an instance of [`Member`][enum_extensions.members.Member]. Example: ```python assert is_member(member(13)) assert not is_member(13) ``` Arguments: item: An instance to check. Returns: Whether an item is an instance of [`Member`][enum_extensions.members.Member]. \"\"\" return is_instance ( item , Member )","title":"is_member()"},{"location":"reference/members/#enum_extensions.members.is_non_member","text":"Checks if an item is an instance of NonMember . Example assert is_non_member ( non_member ( 25 )) assert not is_non_member ( 25 ) Parameters: Name Type Description Default item MaybeNonMember [ T ] An instance to check. required Returns: Type Description TypeGuard [ NonMember [ T ]] Whether an item is an instance of NonMember . Source code in enum_extensions/members.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def is_non_member ( item : MaybeNonMember [ T ]) -> TypeGuard [ NonMember [ T ]]: \"\"\"Checks if an `item` is an instance of [`NonMember`][enum_extensions.members.NonMember]. Example: ```python assert is_non_member(non_member(25)) assert not is_non_member(25) ``` Arguments: item: An instance to check. Returns: Whether an item is an instance of [`NonMember`][enum_extensions.members.NonMember]. \"\"\" return is_instance ( item , NonMember )","title":"is_non_member()"},{"location":"reference/traits/","text":"Trait Base type to derive traits from. Source code in enum_extensions/traits.py 11 12 13 14 15 16 class Trait : \"\"\"Base type to derive traits from.\"\"\" name : str value : Any title_name : str Format Bases: Trait Enforces enumeration string formatting. Source code in enum_extensions/traits.py 19 20 21 22 23 class Format ( Trait ): \"\"\"Enforces enumeration string formatting.\"\"\" def __format__ ( self , specification : str ) -> str : return str ( self ) . __format__ ( specification ) Order Bases: Trait Implements ordering for enumerations. Source code in enum_extensions/traits.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Order ( Trait ): \"\"\"Implements ordering for enumerations.\"\"\" def __lt__ ( self : T , other : T ) -> bool : if is_same_type ( other , self ): return self . value < other . value return NotImplemented def __le__ ( self : T , other : T ) -> bool : if is_same_type ( other , self ): return self . value <= other . value return NotImplemented def __gt__ ( self : T , other : T ) -> bool : if is_same_type ( other , self ): return self . value > other . value return NotImplemented def __ge__ ( self : T , other : T ) -> bool : if is_same_type ( other , self ): return self . value >= other . value return NotImplemented Title Bases: Trait Allows handling abbreviations in titles. Source code in enum_extensions/traits.py 54 55 56 57 58 59 60 61 62 63 64 65 66 class Title ( Trait ): \"\"\"Allows handling abbreviations in titles.\"\"\" ABBREVIATIONS : ClassVar [ Set [ str ]] = set () @dynamic_attribute def title_name ( self ) -> str : # type: ignore name = self . name if name in self . ABBREVIATIONS : return name return super () . title_name","title":"Traits"},{"location":"reference/traits/#enum_extensions.traits.Trait","text":"Base type to derive traits from. Source code in enum_extensions/traits.py 11 12 13 14 15 16 class Trait : \"\"\"Base type to derive traits from.\"\"\" name : str value : Any title_name : str","title":"Trait"},{"location":"reference/traits/#enum_extensions.traits.Format","text":"Bases: Trait Enforces enumeration string formatting. Source code in enum_extensions/traits.py 19 20 21 22 23 class Format ( Trait ): \"\"\"Enforces enumeration string formatting.\"\"\" def __format__ ( self , specification : str ) -> str : return str ( self ) . __format__ ( specification )","title":"Format"},{"location":"reference/traits/#enum_extensions.traits.Order","text":"Bases: Trait Implements ordering for enumerations. Source code in enum_extensions/traits.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Order ( Trait ): \"\"\"Implements ordering for enumerations.\"\"\" def __lt__ ( self : T , other : T ) -> bool : if is_same_type ( other , self ): return self . value < other . value return NotImplemented def __le__ ( self : T , other : T ) -> bool : if is_same_type ( other , self ): return self . value <= other . value return NotImplemented def __gt__ ( self : T , other : T ) -> bool : if is_same_type ( other , self ): return self . value > other . value return NotImplemented def __ge__ ( self : T , other : T ) -> bool : if is_same_type ( other , self ): return self . value >= other . value return NotImplemented","title":"Order"},{"location":"reference/traits/#enum_extensions.traits.Title","text":"Bases: Trait Allows handling abbreviations in titles. Source code in enum_extensions/traits.py 54 55 56 57 58 59 60 61 62 63 64 65 66 class Title ( Trait ): \"\"\"Allows handling abbreviations in titles.\"\"\" ABBREVIATIONS : ClassVar [ Set [ str ]] = set () @dynamic_attribute def title_name ( self ) -> str : # type: ignore name = self . name if name in self . ABBREVIATIONS : return name return super () . title_name","title":"Title"},{"location":"reference/unique/","text":"unique ( enum ) Ensures that the enumeration does not have aliases. Example from enum_extensions import Enum , unique @unique class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 R , G , B = RED , GREEN , BLUE Traceback ( most recent call last ): ... ValueError : aliases found in ` Color ` : ` R ` -> ` RED ` , ` G ` -> ` GREEN ` , ` B ` -> ` BLUE ` Parameters: Name Type Description Default enum ET The enumeration to check. required Raises: Type Description ValueError Aliases were found. Returns: Type Description ET The enumeration checked. Source code in enum_extensions/unique.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def unique ( enum : ET ) -> ET : \"\"\"Ensures that the enumeration does not have aliases. Example: ```python from enum_extensions import Enum, unique @unique class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 R, G, B = RED, GREEN, BLUE ``` ```python Traceback (most recent call last): ... ValueError: aliases found in `Color`: `R` -> `RED`, `G` -> `GREEN`, `B` -> `BLUE` ``` Arguments: enum: The enumeration to check. Raises: ValueError: Aliases were found. Returns: The enumeration checked. \"\"\" duplicates = concat_comma_space ( maps ( tick ( name ), tick ( member_name )) for name , member_name in find_duplicates ( enum ) ) if duplicates : raise ValueError ( ALIASES_FOUND . format ( tick ( get_name ( enum )), duplicates )) return enum","title":"Unique"},{"location":"reference/unique/#enum_extensions.unique.unique","text":"Ensures that the enumeration does not have aliases. Example from enum_extensions import Enum , unique @unique class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 R , G , B = RED , GREEN , BLUE Traceback ( most recent call last ): ... ValueError : aliases found in ` Color ` : ` R ` -> ` RED ` , ` G ` -> ` GREEN ` , ` B ` -> ` BLUE ` Parameters: Name Type Description Default enum ET The enumeration to check. required Raises: Type Description ValueError Aliases were found. Returns: Type Description ET The enumeration checked. Source code in enum_extensions/unique.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def unique ( enum : ET ) -> ET : \"\"\"Ensures that the enumeration does not have aliases. Example: ```python from enum_extensions import Enum, unique @unique class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 R, G, B = RED, GREEN, BLUE ``` ```python Traceback (most recent call last): ... ValueError: aliases found in `Color`: `R` -> `RED`, `G` -> `GREEN`, `B` -> `BLUE` ``` Arguments: enum: The enumeration to check. Raises: ValueError: Aliases were found. Returns: The enumeration checked. \"\"\" duplicates = concat_comma_space ( maps ( tick ( name ), tick ( member_name )) for name , member_name in find_duplicates ( enum ) ) if duplicates : raise ValueError ( ALIASES_FOUND . format ( tick ( get_name ( enum )), duplicates )) return enum","title":"unique()"}]}